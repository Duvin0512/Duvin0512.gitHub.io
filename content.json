{"meta":{"title":"Duvin's Blog","subtitle":"","description":"","author":"Duvin","url":"https://Duvin0512.github.io.","root":"/"},"pages":[{"title":"404 Not Found","date":"2022-09-25T11:08:37.467Z","updated":"2020-05-28T11:21:40.000Z","comments":true,"path":"404.html","permalink":"https://duvin0512.github.io./404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-05-28T05:02:23.000Z","updated":"2020-05-28T08:43:14.000Z","comments":false,"path":"about/index.html","permalink":"https://duvin0512.github.io./about/index.html","excerpt":"","text":"博客简介专注于学习和创造，而不是娱乐和消遣 博客计划每周两篇，学习python、数据库、算法、数据结构等知识。"},{"title":"归档","date":"2020-05-28T05:16:55.000Z","updated":"2020-05-28T05:21:44.000Z","comments":false,"path":"archives/index.html","permalink":"https://duvin0512.github.io./archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2022-09-25T11:08:37.492Z","updated":"2020-05-28T11:25:22.000Z","comments":true,"path":"categories/index.html","permalink":"https://duvin0512.github.io./categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-09-25T11:08:37.942Z","updated":"2020-05-28T11:25:16.000Z","comments":true,"path":"mylist/index.html","permalink":"https://duvin0512.github.io./mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-09-25T11:08:37.952Z","updated":"2020-05-28T11:25:18.000Z","comments":true,"path":"tags/index.html","permalink":"https://duvin0512.github.io./tags/index.html","excerpt":"","text":""}],"posts":[{"title":"换电脑或重置电脑后如何迁移hexo博客","slug":"blog_2","date":"2022-09-27T16:00:00.000Z","updated":"2022-09-28T10:49:32.468Z","comments":true,"path":"2022/09/28/blog_2/","link":"","permalink":"https://duvin0512.github.io./2022/09/28/blog_2/","excerpt":"备份旧电脑博客文件 准备工作环境 将备份文件迁移至新电脑 下载hexo的git工具","text":"备份旧电脑博客文件 准备工作环境 将备份文件迁移至新电脑 下载hexo的git工具 1. 备份旧电脑博客文件找到旧电脑中博客文件所在的文件夹，删除node_modules文件夹，将其余文件全部备份。 2. 准备新电脑工作环境2.1 下载安装git并配置ssh2.1.1 git下载地址：https://git-scm.com/downloads下载安装完成后，打开git bash设置用户，注意这个不是登录，是给电脑设置一个用户，等上传博客的时候，告诉远程仓库是谁上传的。 git config --global user.name &quot;你的名字&quot; git config --global user.email &quot;你的邮箱&quot; 2.1.2 创建SSH KEY首先使用~/.ssh或者~/.ssh ls命令来查询电脑上是否有.ssh文件夹 （若电脑已有.ssh文件夹，则可跳过这一步）接着在git bash中输入$ ssh-keygen -t rsa -C &quot;你的邮箱&quot;会出现一系列提示语句： Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/DUVIN/.ssh/id_rsa):输入一个文件名，用于保存刚才生成的SSH key代码。可以直接回车，会默认生成id_rsa和id_rsa.pub两个秘钥文件。 创建好.ssh这个文件夹，会提示：Created directory ‘/c/Users/DUVIN/.ssh’. Enter passphrase (empty for no passphrase):输入密码，如果设置了密码，在使用ssh传输文件的时候，需要输入该密码。建议不用设置，直接回车。 Enter same passphrase again:再输一次密码以此确认。若上一步没设置密码，直接回车即可。 至此秘钥设置完成：Your identification has been saved in /c/Users/…/.ssh/id_rsaYour public key has been saved in /c/Users/…/.ssh/id_rsa.pub 最后还将展示设置好的秘钥（不可透露给他人）： 此时SSH KEY设置成功，使用~/.ssh查询.ssh文件所在位置。 2.1.3 添加SSH KEY到Github打开GitHub账户，进入设置，选择SSH and GPG keys 点击右上角新建一个SSH KEY，title随便写，也可以不写。根据上面查询到的.ssh文件路径，用记事本打开id_rsa.pub文件，将其全选复制粘贴到Key中。 2.1.4 测试该SSH KEY在git bash中输入$ ssh -T git@github.com，按照出现的提示输入yes，当看到如图最后一行提示则表示SSH设置成功。 2.2 安装node.js在官网https://nodejs.org/zh-cn/ 下载长期支持版，一路next 2.3 安装hexo在git bash中输入npm install hexo-cli -g,如果显示无法识别npm命令也可打开cmd输入该命令安装。 3.将备份文件迁移至新电脑将拷贝下来的文件夹复制到自己想放的位置即可。然后进入复制好的文件中，打开git bash，输入npm install安装依赖。执行完毕后该文件夹中原先删除的node_modules文件夹又再次出现了。 4. 下载hexo的git工具输入命令npm install hexo-deployer-git --save下载完成后，输入hexo clean清除缓存，再输入hexo g -d重新部署提交博客就完成了。","categories":[{"name":"blog","slug":"blog","permalink":"https://duvin0512.github.io./categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://duvin0512.github.io./tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"https://duvin0512.github.io./tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-09-25T11:08:38.132Z","updated":"2020-05-28T12:00:18.000Z","comments":true,"path":"2022/09/25/hello-world/","link":"","permalink":"https://duvin0512.github.io./2022/09/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hello WorldQuick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Matlab_01 基本操作与矩阵输入","slug":"Matlab01","date":"2022-04-21T04:28:00.000Z","updated":"2022-04-21T04:58:34.000Z","comments":true,"path":"2022/04/21/Matlab01/","link":"","permalink":"https://duvin0512.github.io./2022/04/21/Matlab01/","excerpt":"MATLAB as caculator Array operation","text":"MATLAB as caculator Array operation MATLAB as caculator运算优先级 从左到右次序 先乘除后加减 优先级 Parenthesis () Power (ˆ) Multiplication and division (*,/) Addition and subtraction (+,-) 常用数学方法语法https://ww2.mathworks.cn/help/matlab/elementary-math.html?lang=en 练习 12345&gt;&gt; cos(((1+2+3+4)^3/5)^0.5)ans = -0.0050 12345&gt;&gt; sin(pi^0.5)+log(tan(1))ans = 1.4228 12345&gt;&gt; 2^(3.5*1.7)ans = 61.8199 12345&gt;&gt; exp(sin(10))ans = 0.5804 变量 变量使用前不需要声明 大小写敏感 变量名开头不能有数字 保留字和关键字不能用作变量 变量混乱使用的例子原本cos是一个三角函数，但由于将cos定义为一个变量，此时cos是指代This string这个字符串，而并非是cos这个三角函数。cos(8)是指字符串的第8个字符。 当出现这种情况时，要将错误使用的关键字或保留字从工作区删除，需要使用过clear XXX命令删除指定的变量，当clear不跟具体变量时是指将工作区里的所有变量删除，此时可能会引起计算数据丢失。 查询变量类型在MATLAB中，可以使用who命令来查询变量，whos命令则可以显示变量更多的信息，如变量类型等。 还可以直接双击工作区具体的变量查询详细信息。 变量格式 short long shortE longE bank hex rat 练习 12345678910111213141516171819&gt;&gt; 3/13+4/14+5/15ans = 0.8498&gt;&gt; format long&gt;&gt; 3/13+4/14+5/15ans = 0.849816849816850&gt;&gt; format rat&gt;&gt; 3/13+4/14+5/15ans = 232/273 命令有无；的区别当命令没有分号时，MATLAB会将运算结果呈现出来，而当加了；之后，则不显示运算结果，当计算数据比较多的时候，相对感觉整洁。 Array operationArray(Vector and Matrix) 行向量row vertor 1a=[1 2 3 4] 列向量column vector 1b=[1;2;3;4] 矩阵输入 1A=[1 21 6;5 17 9;31 2 7] Array Indexing 方法一Indexing 123456789101112&gt;&gt; A(3,2)ans = 2 &gt;&gt; A([1 3],[1 3])ans = 1 6 31 7 方法二Indexing矩阵是按列存储的。 123456789101112131415161718&gt;&gt; A(8)ans = 9 &gt;&gt; A([1 3 5])ans = 1 31 17 &gt;&gt; A([1 3; 1 3])ans = 1 31 1 31 矩阵元素替换123456789101112131415161718192021222324252627282930&gt;&gt; A(1,2)=76A = 1 76 6 5 17 9 31 2 7 &gt;&gt; A(3,2)=0A = 1 76 6 5 17 9 31 0 7 &gt;&gt; A([1 2],[2 3])=0A = 1 0 0 5 0 0 31 0 7 &gt;&gt; A(3,:)=[]A = 1 0 0 5 0 0 Colon operator j:k j:i:k [j,j+1,j+2,…,k] [j,j+i,j+2i,…,k] Array concatenation1234567891011121314151617&gt;&gt; A=[1 2;3 4];&gt;&gt; B=[9 9;9 9];&gt;&gt; F=[A B]F = 1 2 9 9 3 4 9 9 &gt;&gt; F=[A;B]F = 1 2 3 4 9 9 9 9 Array manipulation 运算符+ - * / ^ . &#39; 123&gt;&gt; A=[1 2 3;4 5 4; 9 8 7];&gt;&gt; B=[3 3 3;2 4 9;1 3 1];&gt;&gt; a=2; 1234567&gt;&gt; x1=A+ax1 = 3 4 5 6 7 6 11 10 9 1234567&gt;&gt; x2=A/ax2 = 1/2 1 3/2 2 5/2 2 9/2 4 7/2 1234567&gt;&gt; x3=A./ax3 = 1/2 1 3/2 2 5/2 2 9/2 4 7/2 1234567&gt;&gt; x4=A^ax4 = 36 36 32 60 65 60 104 114 108 1234567&gt;&gt; x5=A.^ax5 = 1 4 9 16 25 16 81 64 49 1234567&gt;&gt; C=A'C = 1 4 9 2 5 8 3 4 7 1234567&gt;&gt; y1=A+By1 = 4 5 6 6 9 13 10 11 8 1234567&gt;&gt; y2=A*By2 = 10 20 24 26 44 61 50 80 106 1234567&gt;&gt; y3=A.*By3 = 3 6 9 8 20 36 9 24 7 1234567&gt;&gt; y4=A/By4 = 1/14 2/7 3/14 7/6 0 1/2 137/42 -2/7 -3/14 1234567&gt;&gt; y5=A./By5 = 1/3 2/3 1 2 5/4 4/9 9 8/3 7 特殊矩阵 单位矩阵eye(n) 零矩阵zeros(n1,n2) 全1矩阵ones(n1,n2) 对角矩阵diag() 矩阵的特殊方法1234567&gt;&gt; A=[1 2 3;0 5 6;7 0 9]A = 1 2 3 0 5 6 7 0 9 12345&gt;&gt; max(A)ans = 7 5 9 12345&gt;&gt; max(max(A))ans = 9 12345&gt;&gt; min(A)ans = 0 0 3 12345&gt;&gt; sum(A)ans = 8 7 18 12345&gt;&gt; mean(A)ans = 8/3 7/3 6 1234567&gt;&gt; sort(A)ans = 0 0 3 1 2 6 7 5 9 1234567&gt;&gt; sortrows(A)ans = 0 5 6 1 2 3 7 0 9 12345&gt;&gt; size(A)ans = 3 3 12345&gt;&gt; length(A)ans = 3 12345&gt;&gt; find(A==5)ans = 5","categories":[{"name":"Matlab","slug":"Matlab","permalink":"https://duvin0512.github.io./categories/Matlab/"}],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"https://duvin0512.github.io./tags/Matlab/"},{"name":"Matlab初阶+中阶","slug":"Matlab初阶-中阶","permalink":"https://duvin0512.github.io./tags/Matlab%E5%88%9D%E9%98%B6-%E4%B8%AD%E9%98%B6/"}]},{"title":"python——数据类型","slug":"python02","date":"2020-07-14T14:10:59.000Z","updated":"2020-07-14T14:38:46.000Z","comments":true,"path":"2020/07/14/python02/","link":"","permalink":"https://duvin0512.github.io./2020/07/14/python02/","excerpt":"引子 数字 字符串 列表 元组 字典 集合 数据类型总结","text":"引子 数字 字符串 列表 元组 字典 集合 数据类型总结 引子1 什么是数据？ x=10，10是我们要存储的数据 2 为何数据要分不同的类型 数据是用来表示状态的，不同的状态就应该用不同的类型的数据去表示 3 数据类型 数字（整形，长整形，浮点型，复数） 字符串 字节串：在介绍字符编码时介绍字节bytes类型 列表 元组 字典 集合 数字整型与浮点型 1234567891011#整型int #作用：年纪，等级，身份证号，qq号等整型数字相关 #定义： age=10 #本质age=int(10)#浮点型float #作用：薪资，身高，体重，体质参数等浮点数相关 salary=3000.3 #本质salary=float(3000.3)#二进制，十进制，八进制，十六进制 其他数字类型（了解） 123456789101112#长整形（了解） 在python2中（python3中没有长整形的概念）： &gt;&gt;&gt; num=2L &gt;&gt;&gt; type(num) &lt;type 'long'&gt;#复数（了解） &gt;&gt;&gt; x=1-2j &gt;&gt;&gt; x.real 1.0 &gt;&gt;&gt; x.imag -2.0 字符串1234#作用：名字，性别，国籍，地址等描述信息#定义：在单引号\\双引号\\三引号内，由一串字符组成name='egon' 需要掌握的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#1、strip,lstrip,rstrip#2、lower,upper#3、startswith,endswith#4、format的三种玩法#5、split,rsplit#6、join#7、replace#8、isdigit#stripname='*egon**'print(name.strip('*'))print(name.lstrip('*'))print(name.rstrip('*'))#lower,uppername='egon'print(name.lower())print(name.upper())#startswith,endswithname='alex_SB'print(name.endswith('SB'))print(name.startswith('alex'))#format的三种玩法res='&#123;&#125; &#123;&#125; &#123;&#125;'.format('egon',18,'male')res='&#123;1&#125; &#123;0&#125; &#123;1&#125;'.format('egon',18,'male')res='&#123;name&#125; &#123;age&#125; &#123;sex&#125;'.format(sex='male',name='egon',age=18)#splitname='root:x:0:0::/root:/bin/bash'print(name.split(':')) #默认分隔符为空格name='C:/a/b/c/d.txt' #只想拿到顶级目录print(name.split('/',1))name='a|b|c'print(name.rsplit('|',1)) #从右开始切分#jointag=' 'print(tag.join(['egon','say','hello','world'])) #可迭代对象必须都是字符串#replacename='alex say :i have one tesla,my name is alex'print(name.replace('alex','SB',1))#isdigit：可以判断bytes和unicode类型,是最常用的用于于判断字符是否为\"数字\"的方法age=input('&gt;&gt;: ')print(age.isdigit()) 其他操作（了解即可） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#1、find,rfind,index,rindex,count#2、center,ljust,rjust,zfill#3、expandtabs#4、captalize,swapcase,title#5、is数字系列#6、is其他#find,rfind,index,rindex,countname='egon say hello'print(name.find('o',1,3)) #顾头不顾尾,找不到则返回-1不会报错,找到了则显示索引# print(name.index('e',2,4)) #同上,但是找不到会报错print(name.count('e',1,3)) #顾头不顾尾,如果不指定范围则查找所有#center,ljust,rjust,zfillname='egon'print(name.center(30,'-'))print(name.ljust(30,'*'))print(name.rjust(30,'*'))print(name.zfill(50)) #用0填充#expandtabsname='egon\\thello'print(name)print(name.expandtabs(1))#captalize,swapcase,titleprint(name.capitalize()) #首字母大写print(name.swapcase()) #大小写翻转msg='egon say hi'print(msg.title()) #每个单词的首字母大写#is数字系列#在python3中num1=b'4' #bytesnum2=u'4' #unicode,python3中无需加u就是unicodenum3='四' #中文数字num4='Ⅳ' #罗马数字#isdigt:bytes,unicodeprint(num1.isdigit()) #Trueprint(num2.isdigit()) #Trueprint(num3.isdigit()) #Falseprint(num4.isdigit()) #False#isdecimal:uncicode#bytes类型无isdecimal方法print(num2.isdecimal()) #Trueprint(num3.isdecimal()) #Falseprint(num4.isdecimal()) #False#isnumberic:unicode,中文数字,罗马数字#bytes类型无isnumberic方法print(num2.isnumeric()) #Trueprint(num3.isnumeric()) #Trueprint(num4.isnumeric()) #True#三者不能判断浮点数num5='4.3'print(num5.isdigit())print(num5.isdecimal())print(num5.isnumeric())'''总结: 最常用的是isdigit,可以判断bytes和unicode类型,这也是最常见的数字应用场景 如果要判断中文数字或罗马数字,则需要用到isnumeric'''#is其他print('===&gt;')name='egon123'print(name.isalnum()) #字符串由字母或数字组成print(name.isalpha()) #字符串只由字母组成print(name.isidentifier())print(name.islower())print(name.isupper())print(name.isspace())print(name.istitle()) 列表123456#作用：多个装备，多个爱好，多门课程，多个女朋友等#定义：[]内可以有多个任意类型的值，逗号分隔my_girl_friends=['alex','wupeiqi','yuanhao',4,5] #本质my_girl_friends=list([...])#或l=list('abc') 123456789#ps:反向步长l=[1,2,3,4,5,6]#正向步长l[0:3:1] #[1, 2, 3]#反向步长l[2::-1] #[3, 2, 1]#列表翻转l[::-1] #[6, 5, 4, 3, 2, 1] 元组1234#作用：存多个值，对比列表来说，元组不可变（是可以当做字典的key的），主要是用来读#定义：与列表类型比，只不过[]换成()age=(11,22,33,44,55)本质age=tuple((11,22,33,44,55)) 字典12345678910#作用：存多个值,key-value存取，取值速度快#定义：key必须是不可变类型，value可以是任意类型info=&#123;'name':'egon','age':18,'sex':'male'&#125; #本质info=dict(&#123;....&#125;)#或info=dict(name='egon',age=18,sex='male')#或info=dict([['name','egon'],('age',18)])#或&#123;&#125;.fromkeys(('name','age','sex'),None) 集合123456789101112131415#作用：去重，关系运算，#定义： 知识点回顾 可变类型是不可hash类型 不可变类型是可hash类型#定义集合: 集合：可以包含多个元素，用逗号分割， 集合的元素遵循三个原则： 1：每个元素必须是不可变类型(可hash，可作为字典的key) 2:没有重复的元素 3：无序注意集合的目的是将不同的值存放到一起，不同的集合间用来做关系运算，无需纠结于集合中单个值 数据类型总结按存储空间的占用分（从低到高） 123456数字字符串集合：无序，即无序存索引相关信息元组：有序，需要存索引相关信息，不可变列表：有序，需要存索引相关信息，可变，需要处理数据的增删改字典：无序，需要存key与value映射的相关信息，可变，需要处理数据的增删改 按存值个数区分 标量／原子类型 数字，字符串 容器类型 列表，元组，字典 按可变不可变区分 可变 列表，字典 不可变 数字，字符串，元组 按访问顺序区分 直接访问 数字 顺序访问（序列类型） 字符串，列表，元组 key值访问（映射类型） 字典","categories":[{"name":"python","slug":"python","permalink":"https://duvin0512.github.io./categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://duvin0512.github.io./tags/python/"},{"name":"python基础","slug":"python基础","permalink":"https://duvin0512.github.io./tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"python——部分语法","slug":"python01","date":"2020-07-12T05:37:04.000Z","updated":"2020-07-14T14:12:20.000Z","comments":true,"path":"2020/07/12/python01/","link":"","permalink":"https://duvin0512.github.io./2020/07/12/python01/","excerpt":"变量 用户与程序交互 基本数据类型 格式化输出 基本运算符 流程控制之if…else 流程控制之while循环 流程控制之for循环","text":"变量 用户与程序交互 基本数据类型 格式化输出 基本运算符 流程控制之if…else 流程控制之while循环 流程控制之for循环 变量什么是变量变量即变化的量，核心是“变”与“量”二字，变即变化，量即衡量状态。 为什么要有变量程序执行的本质就是一系列状态的变化，变是程序执行的直接体现，所以我们需要有一种机制能够反映或者说是保存下来程序执行时状态以及状态的变化。 比如： 英雄的等级为1，打怪升级(变)为10 僵尸的存活状态True，被植物打死了，于是变为False 人的名字为egon，也可以修改为Egon 变量名(相当于门牌号，指向值所在的空间)，等号，变量值name=’Egon’sex=’male’age=18level=10 变量的定义规范 变量名只能是 字母、数字或下划线的任意组合 变量名的第一个字符不能是数字 关键字不能声明为变量名[‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘exec’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘not’, ‘or’, ‘pass’, ‘print’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’] 定义方式 驼峰体 AgeOfOldboy = 56 NumberOfStudents = 80 下划线(推荐使用) age_of_oldboy = 56 number_of_students = 80 定义变量名不好的方式 变量名为中文、拼音 变量名过长 变量名词不达意 定义变量会有：id，type，value 1234567891011121314151617#1 等号比较的是value，#2 is比较的是id#强调：#1. id相同，意味着type和value必定相同#2. value相同type肯定相同，但id可能不同,如下&gt;&gt;&gt; x='Info Egon:18'&gt;&gt;&gt; y='Info Egon:18'&gt;&gt;&gt; id(x)4376607152&gt;&gt;&gt; id(y)4376607408&gt;&gt;&gt;&gt;&gt;&gt; x == yTrue&gt;&gt;&gt; x is yFalse 123456789101112131415#1、在交互式模式下#Python实现int的时候有个小整数池。为了避免因创建相同的值而重复申请内存空间所带来的效率问题， Python解释器会在启动时创建出小整数池，范围是[-5,256]，该范围内的小整数对象是全局解释器范围内被重复使用，永远不会被GC回收#每创建一个-5到256之间的整数，都是直接从这个池里直接拿走一个值，例如&gt;&gt;&gt; y=4&gt;&gt;&gt; id(y)4297641184&gt;&gt;&gt;&gt;&gt;&gt; x=3&gt;&gt;&gt; x+=1&gt;&gt;&gt; id(x)4297641184#在pycharm中#但在pycharm中运行python程序，pycharm出于对性能的考虑，会扩大小整数池的范围，其他的字符串等不可变类型也都包含在内一便采用相同的方式处理了，我们只需要记住这是一种优化机制，至于范围到底多大，无需细究 常量常量即指不变的量，如pai 3.141592653…, 或在程序运行过程中不会改变的量举例，假如老男孩老师的年龄会变，那这就是个变量，但在一些情况下，他的年龄不会变了，那就是常量。在Python中没有一个专门的语法代表常量，程序员约定俗成用变量名全部大写代表常量AGE_OF_OLDBOY = 56 ps:在c语言中有专门的常量定义语法，const int count = 60;一旦定义为常量，更改即会报错 用户与程序交互古时候，我们去银行取钱，需要有一个银行业务员等着我们把自己的账号密码输入给他，然后他去进行验证，成功后，我们再将取款金额输入/告诉他 骄傲的现代人，会为客户提供一台ATM机（就是一台计算机），让ATM机跟用户交互，从而取代人力。然而机器是死的，我们必须为其编写程序来运行，这就要求我们的编程语言中能够有一种能与用户交互，接收用户输入数据的机制 123456#在python3中input：用户输入任何值，都存成字符串类型#在python2中input：用户输入什么类型，就存成什么类型raw_input：等于python3的input 注释随着学习的深入，用不了多久，你就可以写复杂的上千甚至上万行的代码啦，有些代码你花了很久写出来，过了些天再回去看，发现竟然看不懂了，这太正常了。 另外，你以后在工作中会发现，一个项目多是由几个甚至几十个开发人员一起做，你要调用别人写的代码，别人也要用你的，如果代码不加注释，你自己都看不懂，更别说别人了，这产会挨打的。所以为了避免这种尴尬的事情发生，一定要增加你代码的可读性。 代码注释分单行和多行注释， 单行注释用#，多行注释可以用三对双引号””” “”” 代码注释的原则： 不用全部加注释，只需要在自己觉得重要或不好理解的部分加注释即可 注释可以用中文或英文，但不要用拼音 基本数据类型什么是数据？为何要有多种类型的数据？12#数据即变量的值，如age&#x3D;18，18则是我们保存的数据。#变量的是用来反映&#x2F;保持状态以及状态变化的，毫无疑问针对不同的状态就应该用不同类型的数据去标识 12345678910111213141516171819概括地说，编程语言的划分方式有以下三种1、编译型or解释型2、强类型or弱类型2.1 强类型语言： 数据类型不可以被忽略的语言即变量的数据类型一旦被定义，那就不会再改变，除非进行强转。在python中，例如：name &#x3D; &#39;egon&#39;，这个变量name在被赋值的那一刻，数据类型就被确定死了，是字符型，值为&#39;egon&#39;。2.2 弱类型语言：数据类型可以被忽略的语言比如linux中的shell中定义一个变量，是随着调用方式的不同，数据类型可随意切换的那种。3、动态型or静态型3.1 动态语言 ：运行时才进行数据类型检查即在变量赋值时，就确定了变量的数据类型，不用事先给变量指定数据类型3.2 静态语言：需要事先给变量进行数据类型定义所以综上所述，Python是一门解释型的强类型动态语言 数字1234567#int整型定义：age&#x3D;10 #age&#x3D;int(10)用于标识：年龄，等级，身份证号，qq号，个数#float浮点型定义：salary&#x3D;3.1 #salary&#x3D;float(3.1)用于标识：工资，身高，体重， 123456789101112131415161718192021#int（整型）#在32位机器上，整数的位数为32位，取值范围为-2**31～2**31-1，即-2147483648～2147483647#在64位系统上，整数的位数为64位，取值范围为-2**63～2**63-1，即-9223372036854775808～9223372036854775807#long（长整型）#跟C语言不同，Python的长整数没有指定位宽，即：Python没有限制长整数数值的大小，但实际上由于机器内存有限，我们使用的长整数数值不可能无限大。#注意，自从Python2.2起，如果整数发生溢出，Python会自动将整数数据转换为长整数，所以如今在长整数数据后面不加字母L也不会导致严重后果了。#注意：在Python3里不再有long类型了，全都是int&gt;&gt;&gt; a= 2**64&gt;&gt;&gt; type(a) #type()是查看数据类型的方法&lt;type 'long'&gt;&gt;&gt;&gt; b = 2**60&gt;&gt;&gt; type(b)&lt;type 'int'&gt;#complex复数型&gt;&gt;&gt; x=1-2j&gt;&gt;&gt; x.imag-2.0&gt;&gt;&gt; x.real1.0 字符串123在python中，加了引号的字符就是字符串类型，python并没有字符类型。定义：name&#x3D;&#39;egon&#39; #name&#x3D;str(&#39;egon&#39;)用于标识：描述性的内容，如姓名，性别，国籍，种族 123456789101112#单引号、双引号、多引号区别#单双引号没有任何区别，只有下面这种情况，需要考虑单双的配合msg = \"My name is Egon , I'm 18 years old!\"#多引号什么作用呢？作用就是多行字符串必须用多引号msg = '''鹅鹅鹅，曲项向天歌，白毛浮绿水，红掌拨清波。'''print(msg) 1234567#数字可以进行加减乘除等运算，字符串也能，但只能进行\"相加\"和\"相乘\"运算。&gt;&gt;&gt; name='egon'&gt;&gt;&gt; age='18'&gt;&gt;&gt; name+age #相加其实就是简单拼接'egon18'&gt;&gt;&gt; name*5'egonegonegonegonegon' 1234#注意1：字符串相加的效率不高字符串1+字符串3，并不会在字符串1的基础上加字符串2，而是申请一个全新的内存空间存入字符串1和字符串3，相当字符串1与字符串3的空间被复制了一次，#注意2：只能字符串加字符串，不能字符串加其他类型 列表123456789#在[]内用逗号分隔，可以存放n个任意类型的值#定义：students=['egon','alex','wupeiqi',] #students=list(['egon','alex','wupeiqi',])#用于标识：存储多个值的情况，比如一个人有多个爱好#存放多个学生的信息：姓名，年龄，爱好&gt;&gt;&gt; students_info=[['egon',18,['play',]],['alex',18,['play','sleep']]]&gt;&gt;&gt; students_info[0][2][0] #取出第一个学生的第一个爱好'play' 字典1234567891011#为何还要用字典？#存放一个人的信息：姓名，性别，年龄，很明显是多个值，既然是存多个值，我们完全可以基于刚刚学习的列表去存放，如下&gt;&gt;&gt; info=['egon','male',18]#定义列表的目的不单单是为了存，还要考虑取值，如果我想取出这个人的年龄，可以用&gt;&gt;&gt; info[2]18#但这是基于我们已经知道在第3个位置存放的是年龄的前提下，我们才知道索引2对应的是年龄#即： #name, sex, ageinfo=['egon','male',18]#而这完全只是一种假设，并没有真正意义上规定第三个位置存放的是年龄，于是我们需要寻求一种，即可以存放多个任意类型的值，又可以硬性规定值的映射关系的类型，比如key=value，这就用到了字典 1234#在&#123;&#125;内用逗号分隔，可以存放多个key:value的值，value可以是任意类型#定义：info=&#123;'name':'egon','age':18,'sex':18&#125; #info=dict(&#123;'name':'egon','age':18,'sex':18&#125;)#用于标识：存储多个值的情况，每个值都有唯一一个对应的key，可以更为方便高效地取值 123456789101112131415161718info=&#123; 'name':'egon', 'hobbies':['play','sleep'], 'company_info':&#123; 'name':'Oldboy', 'type':'education', 'emp_num':40, &#125;&#125;print(info['company_info']['name']) #取公司名students=[ &#123;'name':'alex','age':38,'hobbies':['play','sleep']&#125;, &#123;'name':'egon','age':18,'hobbies':['read','sleep']&#125;, &#123;'name':'wupeiqi','age':58,'hobbies':['music','read','sleep']&#125;,]print(students[1]['hobbies'][1]) #取第二个学生的第二个爱好 布尔123456789101112131415161718#布尔值，一个True一个False#计算机俗称电脑，即我们编写程序让计算机运行时，应该是让计算机无限接近人脑，或者说人脑能干什么，计算机就应该能干什么，人脑的主要作用是数据运行与逻辑运算，此处的布尔类型就模拟人的逻辑运行，即判断一个条件成立时，用True标识，不成立则用False标识&gt;&gt;&gt; a=3&gt;&gt;&gt; b=5&gt;&gt;&gt;&gt;&gt;&gt; a &gt; b #不成立就是False,即假False&gt;&gt;&gt;&gt;&gt;&gt; a &lt; b #成立就是True, 即真True#接下来就可以根据条件结果来干不同的事情了：if a &gt; b print(a is bigger than b )else print(a is smaller than b )#上面是伪代码，但意味着，计算机已经可以像人脑一样根据判断结果不同，来执行不同的动作。 布尔类型的重点知识！！！：123#所有数据类型都自带布尔值1、None，0，空（空字符串，空列表，空字典等）三种情况下布尔值为False2、其余均为真 重点： 可变类型：在id不变的情况下，value可以变，则称为可变类型，如列表，字典 不可变类型：value一旦改变，id也改变，则称为不可变类型（id变，意味着创建了新的内存空间） 格式化输出程序中经常会有这样场景：要求用户输入信息，然后打印成固定的格式 比如要求用户输入用户名和年龄，然后打印如下格式： My name is xxx，my age is xxx. 很明显，用逗号进行字符串拼接，只能把用户输入的名字和年龄放到末尾，无法放到指定的xxx位置，而且数字也必须经过str(数字)的转换才能与字符串进行拼接。 这就用到了占位符，如：%s、%d 1234567891011121314#%s字符串占位符：可以接收字符串，也可接收数字print('My name is %s,my age is %s' %('egon',18))#%d数字占位符：只能接收数字print('My name is %s,my age is %d' %('egon',18))print('My name is %s,my age is %d' %('egon','18')) #报错#接收用户输入，打印成指定格式name=input('your name: ')age=input('your age: ') #用户输入18,会存成字符串18,无法传给%dprint('My name is %s,my age is %s' %(name,age))#注意：#print('My name is %s,my age is %d' %(name,age)) #age为字符串类型,无法传给%d,所以会报错 基本运算符计算机可以进行的运算有很多种，运算按种类可分为算数运算、比较运算、逻辑运算、赋值运算、成员运算、身份运算、位运算 算数运算 以下假设变量：a=10，b=20 比较运算 以下假设变量：a=10，b=20 赋值运算 以下假设变量：a=10，b=20 逻辑运算 1234567891011121314151617181920212223242526272829303132333435363738#1、三者的优先级关系：not&gt;and&gt;or，同一优先级默认从左往右计算。&gt;&gt;&gt; 3&gt;4 and 4&gt;3 or 1==3 and 'x' == 'x' or 3 &gt;3False#2、最好使用括号来区别优先级，其实意义与上面的一样'''原理为：(1) not的优先级最高，就是把紧跟其后的那个条件结果取反，所以not与紧跟其后的条件不可分割(2) 如果语句中全部是用and连接，或者全部用or连接，那么按照从左到右的顺序依次计算即可(3) 如果语句中既有and也有or，那么先用括号把and的左右两个条件给括起来，然后再进行运算'''&gt;&gt;&gt; (3&gt;4 and 4&gt;3) or (1==3 and 'x' == 'x') or 3 &gt;3False#3、短路运算：逻辑运算的结果一旦可以确定，那么就以当前处计算到的值作为最终结果返回&gt;&gt;&gt; 10 and 0 or '' and 0 or 'abc' or 'egon' == 'dsb' and 333 or 10 &gt; 4我们用括号来明确一下优先级&gt;&gt;&gt; (10 and 0) or ('' and 0) or 'abc' or ('egon' == 'dsb' and 333) or 10 &gt; 4短路： 0 '' 'abc' 假 假 真返回： 'abc'#4、短路运算面试题：&gt;&gt;&gt; 1 or 31&gt;&gt;&gt; 1 and 33&gt;&gt;&gt; 0 and 2 and 10&gt;&gt;&gt; 0 and 2 or 11&gt;&gt;&gt; 0 and 2 or 1 or 41&gt;&gt;&gt; 0 or False and 1False 身份运算12#is比较的是id#而==比较的是值 流程控制之if…else12345678910111213141516# 如果：成绩&gt;=90，那么：优秀# 如果成绩&gt;=80且&lt;90,那么：良好# 如果成绩&gt;=70且&lt;80,那么：普通# 其他情况：很差score=input('&gt;&gt;: ')score=int(score)if score &gt;= 90: print('优秀')elif score &gt;= 80: print('良好')elif score &gt;= 70: print('普通')else: print('很差') 1234567891011121314151617 if 条件1: 缩进的代码块 elif 条件2: 缩进的代码块 elif 条件3: 缩进的代码块 ...... else: 缩进的代码块 流程控制之while循环 为何要用循环 如何做到不用写重复代码又能让程序重复一段代码多次呢？ 循环语句 条件循环：while，语法如下 12345while 条件: # 循环体 # 如果条件为真，那么循环体则执行，执行完毕后再次循环，重新判断条件。。。 # 如果条件为假，那么循环体不执行,循环终止 12345678910111213141516171819#打印0-10count=0while count &lt;= 10: print('loop',count) count+=1#打印0-10之间的偶数count=0while count &lt;= 10: if count%2 == 0: print('loop',count) count+=1#打印0-10之间的奇数count=0while count &lt;= 10: if count%2 == 1: print('loop',count) count+=1 死循环 123456import timenum=0while True: print('count',num) time.sleep(1) num+=1 循环嵌套与tag 12345678910111213 tag=True while tag: ...... while tag: ........ while tag: tag=False 12345678910111213141516171819202122232425262728293031323334353637383940414243#练习，要求如下： 1 循环验证用户输入的用户名与密码 2 认证通过后，运行用户重复执行命令 3 当用户输入命令为quit时，则退出整个程序#实现一：name='egon'password='123'while True: inp_name=input('用户名: ') inp_pwd=input('密码: ') if inp_name == name and inp_pwd == password: while True: cmd=input('&gt;&gt;: ') if not cmd:continue if cmd == 'quit': break print('run &lt;%s&gt;' %cmd) else: print('用户名或密码错误') continue break#实现二：使用tagname='egon'password='123'tag=Truewhile tag: inp_name=input('用户名: ') inp_pwd=input('密码: ') if inp_name == name and inp_pwd == password: while tag: cmd=input('&gt;&gt;: ') if not cmd:continue if cmd == 'quit': tag=False continue print('run &lt;%s&gt;' %cmd) else: print('用户名或密码错误') break与continue 1234567891011#break用于退出本层循环while True: print \"123\" break print \"456\"#continue用于退出本次循环，继续下一次循环while True: print \"123\" continue print \"456\" while+else 12345678910111213141516171819202122232425262728293031323334#与其它语言else 一般只与if 搭配不同，在Python 中还有个while ...else 语句，while 后面的else 作用是指，当while 循环正常执行完，中间没有被break 中止的话，就会执行else后面的语句count = 0while count &lt;= 5 : count += 1 print(\"Loop\",count)else: print(\"循环正常执行完啦\")print(\"-----out of while loop ------\")#输出# Loop 1# Loop 2# Loop 3# Loop 4# Loop 5# Loop 6# 循环正常执行完啦# -----out of while loop ------#如果执行过程中被break啦，就不会执行else的语句啦count = 0while count &lt;= 5 : count += 1 if count == 3:break print(\"Loop\",count)else: print(\"循环正常执行完啦\")print(\"-----out of while loop ------\")# 输出# Loop 1# Loop 2# -----out of while loop ------ 流程控制之for循环 迭代式循环：for，语法如下 123 for i in range(10): 缩进的代码块 break与continue（同上） 循环嵌套 1234for i in range(1,10): for j in range(1,i+1): print('%s*%s=%s' %(i,j,i*j),end=' ') print() 123456789101112131415161718192021222324#分析''' #max_level=5 * #current_level=1，空格数=4，*号数=1 *** #current_level=2,空格数=3,*号数=3 ***** #current_level=3,空格数=2,*号数=5 ******* #current_level=4,空格数=1,*号数=7********* #current_level=5,空格数=0,*号数=9#数学表达式空格数=max_level-current_level*号数=2*current_level-1'''#实现max_level=5for current_level in range(1,max_level+1): for i in range(max_level-current_level): print(' ',end='') #在一行中连续打印多个空格 for j in range(2*current_level-1): print('*',end='') #在一行中连续打印多个空格 print() for+else","categories":[{"name":"python","slug":"python","permalink":"https://duvin0512.github.io./categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://duvin0512.github.io./tags/python/"},{"name":"pyhton基础","slug":"pyhton基础","permalink":"https://duvin0512.github.io./tags/pyhton%E5%9F%BA%E7%A1%80/"}]},{"title":"多任务——协程","slug":"python-socket05","date":"2020-07-03T02:29:38.000Z","updated":"2020-07-03T05:57:30.000Z","comments":true,"path":"2020/07/03/python-socket05/","link":"","permalink":"https://duvin0512.github.io./2020/07/03/python-socket05/","excerpt":"迭代器 生成器 协程-yield 协程-greenlet 协程-gevent 进程、线程、协程区别 案例:并发下载器","text":"迭代器 生成器 协程-yield 协程-greenlet 协程-gevent 进程、线程、协程区别 案例:并发下载器","categories":[{"name":"python","slug":"python","permalink":"https://duvin0512.github.io./categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://duvin0512.github.io./tags/python/"},{"name":"网络编程","slug":"网络编程","permalink":"https://duvin0512.github.io./tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"djago01","slug":"djago01","date":"2020-06-30T07:07:57.000Z","updated":"2020-06-30T07:07:58.000Z","comments":true,"path":"2020/06/30/djago01/","link":"","permalink":"https://duvin0512.github.io./2020/06/30/djago01/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"多线程——进程","slug":"python-socket04","date":"2020-06-30T03:47:10.000Z","updated":"2020-06-30T07:07:08.000Z","comments":true,"path":"2020/06/30/python-socket04/","link":"","permalink":"https://duvin0512.github.io./2020/06/30/python-socket04/","excerpt":"进程以及状态 进程的创建-multiprocessing 进程、线程对比 进程间通信-Queue 进程的创建进程池Pool 案例:文件夹copy器(多进程版)","text":"进程以及状态 进程的创建-multiprocessing 进程、线程对比 进程间通信-Queue 进程的创建进程池Pool 案例:文件夹copy器(多进程版) 进程以及状态 进程 程序：例如xxx.py这是程序，是一个静态的 进程：一个程序运行起来后，代码+用到的资源 称之为进程，它是操作系统分配资源的基本单元。 不仅可以通过线程完成多任务，进程也是可以的 进程的状态 工作中，任务数往往大于cpu的核数，即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，因此导致了有了不同的状态 就绪态：运行的条件都已经慢去，正在等在cpu执行 执行态：cpu正在执行其功能 等待态：等待某些条件满足，例如一个程序sleep了，此时就处于等待态 进程的创建-multiprocessingmultiprocessing模块就是跨平台版本的多进程模块，提供了一个Process类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情 2个while循环一起执行 123456789101112131415161718# -*- coding:utf-8 -*-from multiprocessing import Processimport timedef run_proc(): \"\"\"子进程要执行的代码\"\"\" while True: print(\"----2----\") time.sleep(1)if __name__=='__main__': p = Process(target=run_proc) p.start() while True: print(\"----1----\") time.sleep(1) 说明 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动 进程pid 1234567891011121314# -*- coding:utf-8 -*-from multiprocessing import Processimport osimport timedef run_proc(): \"\"\"子进程要执行的代码\"\"\" print('子进程运行中，pid=%d...' % os.getpid()) # os.getpid获取当前进程的进程号 print('子进程将要结束...')if __name__ == '__main__': print('父进程pid: %d' % os.getpid()) # os.getpid获取当前进程的进程号 p = Process(target=run_proc) p.start() Process语法结构如下： Process([group [, target [, name [, args [, kwargs]]]]]) target：如果传递了函数的引用，可以任务这个子进程就执行这里的代码 args：给target指定的函数传递的参数，以元组的方式传递 kwargs：给target指定的函数传递命名参数 name：给进程设定一个名字，可以不设定 group：指定进程组，大多数情况下用不到 Process创建的实例对象的常用方法： start()：启动子进程实例（创建子进程） is_alive()：判断进程子进程是否还在活着 join([timeout])：是否等待子进程执行结束，或等待多少秒 terminate()：不管任务是否完成，立即终止子进程 Process创建的实例对象的常用属性： name：当前进程的别名，默认为Process-N，N为从1开始递增的整数 pid：当前进程的pid（进程号） 给子进程指定的函数传递参数 123456789101112131415161718# -*- coding:utf-8 -*-from multiprocessing import Processimport osfrom time import sleepdef run_proc(name, age, **kwargs): for i in range(10): print('子进程运行中，name= %s,age=%d ,pid=%d...' % (name, age, os.getpid())) print(kwargs) sleep(0.2)if __name__=='__main__': p = Process(target=run_proc, args=('test',18), kwargs=&#123;\"m\":20&#125;) p.start() sleep(1) # 1秒中之后，立即结束子进程 p.terminate() p.join() 运行结果: 12345678910子进程运行中，name&#x3D; test,age&#x3D;18 ,pid&#x3D;45097...&#123;&#39;m&#39;: 20&#125;子进程运行中，name&#x3D; test,age&#x3D;18 ,pid&#x3D;45097...&#123;&#39;m&#39;: 20&#125;子进程运行中，name&#x3D; test,age&#x3D;18 ,pid&#x3D;45097...&#123;&#39;m&#39;: 20&#125;子进程运行中，name&#x3D; test,age&#x3D;18 ,pid&#x3D;45097...&#123;&#39;m&#39;: 20&#125;子进程运行中，name&#x3D; test,age&#x3D;18 ,pid&#x3D;45097...&#123;&#39;m&#39;: 20&#125; 进程间不同享全局变量 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-from multiprocessing import Processimport osimport timenums = [11, 22]def work1(): \"\"\"子进程要执行的代码\"\"\" print(\"in process1 pid=%d ,nums=%s\" % (os.getpid(), nums)) for i in range(3): nums.append(i) time.sleep(1) print(\"in process1 pid=%d ,nums=%s\" % (os.getpid(), nums))def work2(): \"\"\"子进程要执行的代码\"\"\" print(\"in process2 pid=%d ,nums=%s\" % (os.getpid(), nums))if __name__ == '__main__': p1 = Process(target=work1) p1.start() p1.join() p2 = Process(target=work2) p2.start() 运行结果: 12345in process1 pid&#x3D;11349 ,nums&#x3D;[11, 22]in process1 pid&#x3D;11349 ,nums&#x3D;[11, 22, 0]in process1 pid&#x3D;11349 ,nums&#x3D;[11, 22, 0, 1]in process1 pid&#x3D;11349 ,nums&#x3D;[11, 22, 0, 1, 2]in process2 pid&#x3D;11350 ,nums&#x3D;[11, 22] 进程、线程对比功能进程，能够完成多任务，比如 在一台电脑上能够同时运行多个QQ线程，能够完成多任务，比如 一个QQ中的多个聊天窗口 定义的不同进程是系统进行资源分配和调度的一个独立单位. 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 区别一个程序至少有一个进程,一个进程至少有一个线程.线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率线线程不能够独立执行，必须依存在进程中可以将进程理解为工厂中的一条流水线，而其中的线程就是这个流水线上的工人 优缺点线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。 进程间通信-QueueProcess之间有时需要通信，操作系统提供了很多机制来实现进程间的通信。 Queue的使用 可以使用multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序，首先用一个小实例来演示一下Queue的工作原理： 12345678910111213141516171819202122232425262728#coding=utf-8from multiprocessing import Queueq=Queue(3) #初始化一个Queue对象，最多可接收三条put消息q.put(\"消息1\")q.put(\"消息2\")print(q.full()) #Faleq.put(\"消息3\")print(q.full()) #True#因为消息列队已满下面的try都会抛出异常，第一个try会等待2秒后再抛出异常，第二个Try会立刻抛出异常try: q.put(\"消息4\",True,2)except: print(\"消息列队已满，现有消息数量:%s\"%q.qsize())try: q.put_nowait(\"消息4\")except: print(\"消息列队已满，现有消息数量:%s\"%q.qsize())#推荐的方式，先判断消息列队是否已满，再写入if not q.full(): q.put_nowait(\"消息4\")#读取消息时，先判断消息列队是否为空，再读取if not q.empty(): for i in range(q.qsize()): print(q.get_nowait()) 运行结果: 1234567FalseTrue消息列队已满，现有消息数量:3消息列队已满，现有消息数量:3消息1消息2消息3 说明 初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）； Queue.qsize()：返回当前队列包含的消息数量； Queue.empty()：如果队列为空，返回True，反之False ； Queue.full()：如果队列满了，返回True,反之False； Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True； 1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出”Queue.Empty”异常； 2）如果block值为False，消息列队如果为空，则会立刻抛出”Queue.Empty”异常； Queue.get_nowait()：相当Queue.get(False)； Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True； 1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full”异常； 2）如果block值为False，消息列队如果没有空间可写入，则会立刻抛出”Queue.Full”异常； Queue.put_nowait(item)：相当Queue.put(item, False)； Queue实例 我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据： 1234567891011121314151617181920212223242526272829303132333435from multiprocessing import Process, Queueimport os, time, random# 写数据进程执行的代码:def write(q): for value in ['A', 'B', 'C']: print('Put %s to queue...' % value) q.put(value) time.sleep(random.random())# 读数据进程执行的代码:def read(q): while True: if not q.empty(): value = q.get(True) print('Get %s from queue.' % value) time.sleep(random.random()) else: breakif __name__=='__main__': # 父进程创建Queue，并传给各个子进程： q = Queue() pw = Process(target=write, args=(q,)) pr = Process(target=read, args=(q,)) # 启动子进程pw，写入: pw.start() # 等待pw结束: pw.join() # 启动子进程pr，读取: pr.start() pr.join() # pr进程里是死循环，无法等待其结束，只能强行终止: print('') print('所有数据都写入并且读完') 运行结果： 进程的创建进程池Pool进程池Pool当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。 初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务，请看下面的实例： 12345678910111213141516171819202122# -*- coding:utf-8 -*-from multiprocessing import Poolimport os, time, randomdef worker(msg): t_start = time.time() print(\"%s开始执行,进程号为%d\" % (msg,os.getpid())) # random.random()随机生成0~1之间的浮点数 time.sleep(random.random()*2) t_stop = time.time() print(msg,\"执行完毕，耗时%0.2f\" % (t_stop-t_start))po = Pool(3) # 定义一个进程池，最大进程数3for i in range(0,10): # Pool().apply_async(要调用的目标,(传递给目标的参数元祖,)) # 每次循环将会用空闲出来的子进程去调用目标 po.apply_async(worker,(i,))print(\"----start----\")po.close() # 关闭进程池，关闭后po不再接收新的请求po.join() # 等待po中所有子进程执行完成，必须放在close语句之后print(\"-----end-----\") 运行结果: 12345678910111213141516171819202122----start----0开始执行,进程号为214661开始执行,进程号为214682开始执行,进程号为214670 执行完毕，耗时1.013开始执行,进程号为214662 执行完毕，耗时1.244开始执行,进程号为214673 执行完毕，耗时0.565开始执行,进程号为214661 执行完毕，耗时1.686开始执行,进程号为214684 执行完毕，耗时0.677开始执行,进程号为214675 执行完毕，耗时0.838开始执行,进程号为214666 执行完毕，耗时0.759开始执行,进程号为214687 执行完毕，耗时1.038 执行完毕，耗时1.059 执行完毕，耗时1.69-----end----- multiprocessing.Pool常用函数解析： apply_async(func[, args[, kwds]]) ：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表； close()：关闭Pool，使其不再接受新的任务； terminate()：不管任务是否完成，立即终止； join()：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用； 进程池中的Queue如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()，否则会得到一条如下的错误信息： RuntimeError: Queue objects should only be shared between processes through inheritance. 下面的实例演示了进程池中的进程如何通信： 12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# 修改import中的Queue为Managerfrom multiprocessing import Manager,Poolimport os,time,randomdef reader(q): print(\"reader启动(%s),父进程为(%s)\" % (os.getpid(), os.getppid())) for i in range(q.qsize()): print(\"reader从Queue获取到消息：%s\" % q.get(True))def writer(q): print(\"writer启动(%s),父进程为(%s)\" % (os.getpid(), os.getppid())) for i in \"itcast\": q.put(i)if __name__==\"__main__\": print(\"(%s) start\" % os.getpid()) q = Manager().Queue() # 使用Manager中的Queue po = Pool() po.apply_async(writer, (q,)) time.sleep(1) # 先让上面的任务向Queue存入数据，然后再让下面的任务开始从中取数据 po.apply_async(reader, (q,)) po.close() po.join() print(\"(%s) End\" % os.getpid()) 运行结果: 12345678910(11095) startwriter启动(11097),父进程为(11095)reader启动(11098),父进程为(11095)reader从Queue获取到消息：ireader从Queue获取到消息：treader从Queue获取到消息：creader从Queue获取到消息：areader从Queue获取到消息：sreader从Queue获取到消息：t(11095) End 案例:文件夹copy器(多进程版)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import multiprocessingimport osimport timeimport randomdef copy_file(queue, file_name,source_folder_name, dest_folder_name): \"\"\"copy文件到指定的路径\"\"\" f_read = open(source_folder_name + \"/\" + file_name, \"rb\") f_write = open(dest_folder_name + \"/\" + file_name, \"wb\") while True: time.sleep(random.random()) content = f_read.read(1024) if content: f_write.write(content) else: break f_read.close() f_write.close() # 发送已经拷贝完毕的文件名字 queue.put(file_name)def main(): # 获取要复制的文件夹 source_folder_name = input(\"请输入要复制文件夹名字:\") # 整理目标文件夹 dest_folder_name = source_folder_name + \"[副本]\" # 创建目标文件夹 try: os.mkdir(dest_folder_name) except: pass # 如果文件夹已经存在，那么创建会失败 # 获取这个文件夹中所有的普通文件名 file_names = os.listdir(source_folder_name) # 创建Queue queue = multiprocessing.Manager().Queue() # 创建进程池 pool = multiprocessing.Pool(3) for file_name in file_names: # 向进程池中添加任务 pool.apply_async(copy_file, args=(queue, file_name, source_folder_name, dest_folder_name)) # 主进程显示进度 pool.close() all_file_num = len(file_names) while True: file_name = queue.get() if file_name in file_names: file_names.remove(file_name) copy_rate = (all_file_num-len(file_names))*100/all_file_num print(\"\\r%.2f...(%s)\" % (copy_rate, file_name) + \" \"*50, end=\"\") if copy_rate &gt;= 100: break print()if __name__ == \"__main__\": main()","categories":[{"name":"python","slug":"python","permalink":"https://duvin0512.github.io./categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://duvin0512.github.io./tags/python/"},{"name":"网络编程","slug":"网络编程","permalink":"https://duvin0512.github.io./tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"多任务——线程","slug":"python-socket03","date":"2020-06-29T05:14:21.000Z","updated":"2020-06-30T03:52:02.000Z","comments":true,"path":"2020/06/29/python-socket03/","link":"","permalink":"https://duvin0512.github.io./2020/06/29/python-socket03/","excerpt":"线程⭐ 线程-注意点 多线程-共享全局变量⭐ 多线程-共享全局变量-问题 同步 互斥锁⭐ 死锁 案例:多任务版udp聊天器","text":"线程⭐ 线程-注意点 多线程-共享全局变量⭐ 多线程-共享全局变量-问题 同步 互斥锁⭐ 死锁 案例:多任务版udp聊天器 线程⭐python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用 使用threading模块单线程执行 12345678910#coding=utf-8import timedef Hello(): print(\"你好！\") time.sleep(1)if __name__ == \"__main__\": for 1 in range(5): Hello() 多线程执行 123456789101112#coding=utf-8import threadingimport timedef Hello(): print(\"你好！\") time.sleep(1)if __name__ == \"__main__\": for 1 in range(5): t = threading.Thread(target=Hello) t.satrt() 说明 1. 可以明显看出使用了多线程并发的操作，花费时间要短很多 2. 当调用start() 时，才会真正的创建线程，并且开始执行 主线程会等待所有的子线程结束后才结束 1234567891011121314151617181920212223242526#coding=utf-8import threadingfrom time import sleep, ctimedef sing(): for i in range(3): print(\"正在唱歌...%d\"%i) sleep(1)def dance(): for i in range(6): print(\"正在跳舞...%d\"%i) sleep(1)if __name__ == \"__main__\": print('---开始---:%s'%ctime()) t1 = threading. Thread( target=sing) t2 = threading. Thread( target=dance) t1.start() t2.start() #sleep(5) #屏蔽此行代码,程序会立马结束 print('---结束---:%s'%ctime()) 查看线程数量 12345678910111213141516171819202122232425262728293031#coding=utf-8import threadingfrom time import sleep, ctimedef sing(): for i in range(3): print(\"正在唱歌...%d\"%i) sleep(1)def dance(): for i in range(6): print(\"正在跳舞...%d\"%i) sleep(1)if __name__ == \"__main__\": print('---开始---:%s'%ctime()) t1 = threading. Thread( target=sing) t2 = threading. Thread( target=dance) t1.start() t2.start() while True: length = len(threading.enumerate()) print('当前运行的线程数为: %d'%length) if length&lt;=1: break sleep(0.5) 线程-注意点 线程执行代码的封装 通过上一小节，能够看出，通过使用threading模块能完成多任务的程序开发，为了让每个线程的封装性更完美，所以使用threading模块时，往往会定义一个新的子类class，只要继承threading。Thread就可以了，然后重写run方法 示例如下: 12345678910111213141516#coding=utf-8import threadingimport timeclass MyThread(threading.Thread): def run(self): for i in range(3): time.sleep(1) msg = \"I'm \"+self.name+' @ '+str(i) #name 属性中保存的是当前线程的名字 print(msg)if __name__ == '__main__': t = MyThread() t.start() 多线程-共享全局变量⭐1234567891011121314151617181920212223242526from threading import Threadimport timeg_num = 100def work1(): global g__num for i in range(3): g_num += 1 print(\"----in work1, g_num is %d---\"%g_num)def work2(): global g_num print(\"----in work2, g_num is %d---\"%g_num)print(\"---线程创建之前g_num is %d---\"%g_num)t1 = Thread(target=work1)t1.start()#延时一会，保证t1线程中的事情做完time.sleep(1)t2 = Thread(target=work2)t2.start() 列表当做实参传递到线程中12345678910111213141516171819from threading import Threadimport timedef work1(nums): nums.append(44) print(\"----in work1---\" ,nums)def work2(nums): #延时一会，保证t1线程中的事情做完 time.sleep(1) print(\"----in work2---\" ,nums)g_nums = [11,22,33]t1 = Thread(target=work1, args=(g_nums,))t1.start()t2 = Thread(target=work2, args=(g_nums,))t2.start() 运行结果: 12----in work1--- [11, 22, 33, 44]----in work2--- [11, 22, 33, 44] 总结: 在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据 缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱(即线程非安全) 多线程-共享全局变量-问题多线程开发可能遇到的问题 假设两个线程t1和t2都要对全局变量g_num(默认是0)进行加1运算，t1和t2都各对g_num加10次，g_num的最终的结果应该为20 但是由于是多线程同时操作，有可能出现下面情况: 在g_num=0时,t1取得g_num=0.此时系统把t1调度为”sleeping”状态，把t2转换为”running”状态,t2也获得g_num=0 然后t2对得到的值进行加1并赋给g_num,使得g_num=1 然后系统又把t2调度为”sleeping”,把t1转为”running”.线程t1又把它之前得到的0加1后赋值给g_num 这样导致虽然t1和t2都对g_num加1,但结果仍然是g_num=1 1234567891011121314151617181920212223242526272829from threading import Threadimport timeg_num = 100def work1(num): global g_num for i in range(num): g_num += 1 print(\"----in work1, g_num is %d---\"%g_num)def work2(num): global g_num for i in range(num): g_num += 1 print(\"----in work2, g_num is %d---\"%g_num)def main(): t1 = threading.Thread( target=work1, args=(1000000,)) t2 = threading.Thread( target=work2, args=(1000000,)) t1.start() t2.start() #等待上面的2个线程执行完毕. time.sleep(2)if __name__ == '__main__': main() 同步同步的概念同步就是协同步调，按预定的先后次序进行运行 如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行；B执行，再将结果给A；A再继续操作 解决线程同时修改全局变量的方式 系统调用t1，然后获取到g_num的值为0，此时上一把锁，即不允许其他线程操作g_num t1对g_num的值进行+1 t1解锁，此时g_num的值为1，其他的线程就可以使用g_num了，而且是g_num的值不是0而是1 同理其他线程在对g_num进行修改时，都要先上锁，处理完后再解锁，在上锁的整个过程中不允许其他线程访问，就保证了数据的正确性 互斥锁⭐当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制 线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁 互斥锁为资源引入一个状态:锁定/非锁定 某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。 threading模块中定义了Lock类，可以方便的处理锁定: 12345678#创建锁mutex = threading.Lock()#锁定mutex.acquire()#释放mutex.release( ) 注意: 如果这个锁之前是没有上锁的，那么acquire不会堵塞 如果在调用acquire对这个锁上锁之前它已经被其他线程上了锁，那么此时acquire会堵塞，直到这个锁被解锁为止 123456789101112131415161718192021222324252627282930313233343536373839import timeimport threadingg_num = 100def work1(num): global g_num # 上锁如果之前没有被上锁，那么此时上锁成功 # 如果上锁之前已经被上锁了，那么此时就会堵塞在这里，直到这个锁被解开位置 mutex.acquire() for i in range(num): g_num += 1 # 解锁 mutex.release() print(\"----in work1, g_num is %d---\"%g_num)def work2(num): global g_num mutex.acquire() for i in range(num): g_num += 1 mutex.release() print(\"----in work2, g_num is %d---\"%g_num)# 创建一个互斥锁，默认是没有上锁的mutex = threading.Lock()def main(): t1 = threading.Thread(target=work1, args=(1000000,)) t2 = threading.Thread(target=work2, args=(1000000,)) t1.start() t2.start() #等待上面的2个线程执行完毕. time.sleep(2)if __name__ == \"__main__\": main() 死锁 死锁 在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁 尽管死锁很少发生，但一旦发生就会造成应用的停止响应.下面看一个死锁的例子: 123456789101112131415161718192021222324252627282930313233343536373839import threadingimport timeclass MyThreadl(threading.Thread): def run(self): # 对mutexA上锁 mutexA.acquire() # mutexA上锁后，延时1秒，等待另外那个线程把mutexB上锁 print(self.name+'----do1---up----') time.sleep(1) # 此时会堵塞，因为这个mutexB已经被另外的线程抢先上锁了 mutexB.acquire( ) print(self.name+'----do1---down----') mutexB.release() # 对mutexA解锁 mutexA.release()class MyThread2(threading.Thread): def run(self): # 对mutexB上锁 mutexB.acquire() # mutexB上锁后，延时1秒，等待另外那个线程把mutexA上锁 print(self.name+'----do2---up----') time.sleep(1) # 此时会堵塞，因为这个mutexA已经被另外的线程抢先上锁了 mutexA.acquire() print(self.name+'----do2---down----') mutexA.release() # 对mutexB解锁 mutexB.release()mutexA = threading.Lock()mutexB = threading.Lock()if __name__ == '__main__': t1 = MyThread1() t2 = MyThread2() t1.start() t2.start() 避免死锁 程序设计时要尽量避免(银行家算法) 添加超时时间等 附录-银行家算法[背景知识] 一个银行家如何将一定数目的资金安全地借给若干个客户，使这些客户既能借到钱完成要干的事，同时银行家又能收回全部资金而不至于破产，这就是银行家问题。这个问题同操作系统中资源分配问题十分相似:银行家就像一个操作系统，客户就像运行的进程，银行家的资金就是系统的资源。 [问题的描述] 一个银行家拥有一定数量的资金，有若干个客户要贷款。每个客户须在一开始就声明他所需贷款的总额。若该客户贷款总额不超过银行家的资金总数，银行家可以接收客户的要求。客户贷款是以每次一个资金单位(如1万RMB等)的方式进行的，客户在借满所需的全部单位款额之前可能会等待，但银行家须保证这种等待是有限的，可完成的。 例如:有三个客户C1，C2，C3，向银行家借款，该银行家的资金总额为10个资金单位，其中C1客户要借9个资金单位，C2客户要借3个资金单位，C3客户要借8个资金单位，总计20个资金单位。某一时刻的状态如图所示。 对于a图的状态，按照安全序列的要求，我们选的第一个客户应满足该客户所需的贷款小于等于银行家当前所剩余的钱款，可以看出只有C2客户能被满足: C2客户需1个资金单位，小于银行家手中的2个资金单位，于是银行家把1个资金单位借给C2客户，使之完成工作并归还所借的3个资金单位的钱，进入b图。 同理，银行家把4个资金单位借给C3客户，使其完成工作，在c图中，只剩一个客户C1，它需7个资金单位，这时银行家有8个资金单位，所以C1也能顺利借到钱并完成工作。最后(见图d)银行家收回全部10个资金单位，保证不赔本。那么客户序列{C1，C2，C3}就是个安全序列，按照这个序列贷款，银行家才是安全的。 否则的话，若在图b状态时，银行家把手中的4个资金单位借给了C1，则出现不安全状态；这时C1，C3均不能完成工作，而银行家手中又没有钱了，系统陷入僵持局面，银行家也不能收回投资。 综上所述，银行家算法是从当前状态出发，逐个按安全序列检查各客户谁能完成其工作，然后假定其完成工作且归还全部贷款，再进而检查下一个能完成工作的客户，…。如果所有客户都能完成工作，则找到一个安全序列，银行家才是安全的。 案例:多任务版udp聊天器 说明 编写一个有2个线程的程序 线程1用来接收数据然后显示 线程2用来检测键盘数据然后通过udp发送数据 要求 实现上述要求 总结多任务程序的特点 参考代码: 1234567891011121314151617181920212223242526272829303132333435363738394041import threadingimport socketdef recv_msg(udp_socket): \"\"\"接收数据并显示\"\"\" #接收数据 while True: recv_data = udp_socket.recvfrom( 1024) print(recv_data)def send_msg(udp_socket, dest_ip, dest_port): \"\"\"发送数据\"\"\" #发送数据 while True: send_data = input(\"输入要发送的数据:\") udp_socket.sendto(send_data.encode(\"utf-8\"), (dest_ip, dest_port))def main(): \"\"\"完成udp聊天器的整体控制\"\"\" #1.创建套接字 udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 2.绑定本地信息 udp_socket.bind((\"\", 7890)) # 3.获取对方的ip dest_ip = input(\" 请输入对方的ip:\") dest_port = int(input(\"请输入对方的port:\")) # 4.创建2个线程，去执行相应的功能 t_recv = threading.Thread(target=recv_msg, args=(udp_socket,)) t_send = threading.Thread(target=send_msg, args=(udp_socket, dest_ip, dest_port)) t_recv.start() t_send.start()if __name__ == \"__main__\": main()","categories":[{"name":"python","slug":"python","permalink":"https://duvin0512.github.io./categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://duvin0512.github.io./tags/python/"},{"name":"网络编程","slug":"网络编程","permalink":"https://duvin0512.github.io./tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"网络——TCP","slug":"python-socket02","date":"2020-06-28T05:00:27.000Z","updated":"2020-06-28T10:21:34.000Z","comments":true,"path":"2020/06/28/python-socket02/","link":"","permalink":"https://duvin0512.github.io./2020/06/28/python-socket02/","excerpt":"tcp简介 tcp网络程序-客户端⭐ tcp网络程序-服务器⭐ tcp注意点⭐ 案例:文件下载器 tcp的3次握手 tcp的4次挥手 tcp长连接和短连接 wireshark的使用 tcp/ip简介","text":"tcp简介 tcp网络程序-客户端⭐ tcp网络程序-服务器⭐ tcp注意点⭐ 案例:文件下载器 tcp的3次握手 tcp的4次挥手 tcp长连接和短连接 wireshark的使用 tcp/ip简介 TCP简介TCP介绍TCP协议，传输控制协议(英语: Transmission Control Protocol，缩写为TCP)是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。 TCP通信需要经过创建连接、数据传送、终止连接三个步骤。 TCP通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，”打电话“ TCP特点 面向连接 通信双方必须先建立连接才能进行数据的传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。 双方间的数据传输都可以通过这一个连接进行。 完成数据交换后，双方必须断开此连接，以释放系统资源。 这种连接是一对一的，因此TCP不适用于广播的应用程序，基于广播的应用程序请使用UDP协议。 可靠传输 TCP采用发送应答机制TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功 超时重传发送端发出一个报文段之后就后动定时器，如果在定时时间内没有收到应答就重新发送这个报文段。 TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。 然后接收端实体对已成功收到的包发回一个相应的确认(ACK); 如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。 错误校验TCP用一个校验和函数来检验数据是否有错误;在发送和接收时都要计算校验和。 流量控制和阻塞管理流量控制用来避免主机发送得过快而使接收方来不及完全收下。 TCP与UDP的不同点 面向连接(确认有创建三方交握，连接已创建才作传输。) 有序数据传输 重发丢失的数据包 舍弃重复的数据包 无差错的数据传输 阻塞流量控制 udp通信模型udp通信模型中，在通信开始之前，不需要建立相关的链接，只需要发送数据即可，类似于生活中，”写信“ TCP通信模型udp通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，”打电话“ tcp网络程序-客户端tcp客户端构建流程tcp的客户端要比服务器端简单很多，如果说服务器端是需要自己买手机、查手机卡、设置铃声、等待别人打电话流程的话，那么客户端就只需要找一个电话亭，拿起电话拨打即可，流程要少很多 示例代码: 12345678910111213141516171819202122from socket import *# 创建sockettcp_client_socket = socket(AF_INET, SOCK_STREAM)# 目的信息server_ip = input(\"请输入服务器ip:\")server_port = int(input(\"请输入服务器port:\"))# 链接服务器tcp_client_socket.connect((server_ip, server_port))# 提示用户输入数据send_data = input(\"请输入要发送的数据:\")tcp_client_socket.send(send_data.encode(\"gbk\"))# 接收对方发送过来的数据，最大接收1024个字节recvData = tcp_client_socket.recv(1024)print('接收到的数据为:'，recvData.decode('gbk'))# 关闭套接字tcp_client_socket.close() tcp网络程序-服务器生活中的电话机如果想让别人能更够打通咱们的电话获取相应服务的话，需要做以下几件事情: 买个手机 插上手机卡 设计手机为正常接听状态(即能够响铃) 静静的等着别人拨打 tcp服务器如同上面的电话机过程一样，在程序中，如果想要完成一个tcp服务器的功能，需要的流程如下: socket创建一个套接字 bind绑定ip和port listen使套接字变为可以被动链接 accept等待客户端的链接 recv/send接收发送数据 一个很简单的tcp服务器如下: 12345678910111213141516171819202122232425262728from socket import *# 创建sockettcp_server_socket = socket(AF_INET, SOCK_STREAM)# 本地信息address = (''，7788)# 绑定tcp_server_socket.bind(address)# 使用socket创建的套接字默认的属性是主动的， 使用listen将其变为被动的，这样就可以接收别人的链接了tcp_server_socket.listen(128)# 如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务# client_socket用来为这个客户端服务# tcp_server_socket就可以省下来专门等待其他新客户端的链接client_socket, clientAddr = tcp_server_socket.accept()#接收对方发送过来的数据recv_data = client_socket.recv(1024) # 接收1024个字节print('接收到的数据为:', recv_data.decode('gbk'))# 发送一些数据到客户端client_socket.send(\"thank you !\".encode('gbk'))# 关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了。client_socket.close() 循环为客户端服务并且循环为同一个客户端服务多次： 123456789101112131415161718192021222324252627282930313233343536373839404142import socketdef main(): # 1.创建套接字 socket tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 2.绑定本地信息 bind tcp_server_socket.bind((\"\", 7890)) # 3.让默认的套接字由主动变为被动 listen tcp_server_socket.listen(128) while True: print(\"等待一个新的客户端的到来...\") # 4.等待客户端的连接 accept new_client_socket, client_addr = tcp_server_socket.accept() print(\"一个新的客户端已经到来%s\" % str(client_addr)) while True: # 接收客户端发送过来的请求 recv_data = new_client_socket.recv(1024) print(\"客户端送过来的请求是：%s\" % recv_data.decode(\"utf-8\")) # 如果recv解堵塞，那么有2种方式： # 1.客户端发送过来数据 # 2.客户端调用close导致recv解堵塞 if recv_data: # 回送一部分数据给客户端 new_client_socket.send(\"hello你好\".encode(\"utf-8\")) else: break # 关闭套接字 new_client_socket.close() print(\"已经为这个客户端服务完成...\") tcp_server_socket.close()if __name__ == \"__main__\": main() tcp注意点 tcp服务器一般情况下都需要绑定，否则客户端找不到这个服务器 tp客户端一般不绑定，因为是主动链接服务器，所以只要确定好服务器的ip、port等信息就好，本地客户端可以随机 tcp服务器中通过listen可以将socket创建出来的主动套接字变为被动的，这是做tcp服务器时必须要做的 当客户端需要链接服务器时，就需要使用connect进行链接，udp是不需要链接的而是直接发送，但是tcp必须先链接，只有链接成功才能通信 当一个tcp客户端连接服务器时，服务器端会有1个新的套接字，这个套接字用来标记这个客户端，单独为这个客户端服务 listen后 的套接字是被动套接字，用来接收新的客户端的链接请求的，而accept返回的新套接字是标记这个新客户端的 关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信 关闭accept返回的套接字意味着这个客户端已经服务完毕 当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线 案例:文件下载器服务器 参考代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import socketdef send_file_2_cliebt(new_client_socket, client_addr): # 1.接收客户端需要下载的文件名 # 接收客户端发送过来的要下载的文件名 file_name = new_client_socket.recv(1024).decode(\"UTF-8\") print(\"客户端(%s)需要下载的文件是：%s\" % str(client_addr), file_name) file_content = None # 2.打开这个文件，读取数据 try: f = open(file_name, \"rb\") file_content = f.read() f.close() except Exception as ret: print(\"没有要下载的文件(%s)\" % file_name) # 3.发送文件的数据给客户端 if file_content: new_client_socket.send(file_content)def main(): # 1.创建套接字 socket tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 2.绑定本地信息 bind tcp_server_socket.bind((\"\", 7890)) # 3.让默认的套接字由主动变为被动 listen tcp_server_socket.listen(128) while True: # 4.等待客户端的连接 accept new_client_socket, client_addr = tcp_server_socket.accept() # 调用发送文件函数，完成为客户端服务 send_file_2_cliebt(new_client_socket, client_addr) # 6.关闭套接字 new_client_socket.close() tcp_server_socket.close()if __name__ == \"__main__\": main() 客户端 参考代码： 123456789101112131415161718192021222324252627282930313233from socket import *def main(): #创建socket tcp_client_socket = socket(AF_INET, SOCK_STREAM) #目的信息 server_ip = input(\"请输入服务器ip:\") server_port = int( input(\"请输入服务器port:\")) #链接服务器 tcp_client_socket.connect((server_ip, server_port)) #输入需要下载的文件名 file_name = input(\"请输入要下载的文件名:\") #发送文件下载请求 tcp_client_socket.send(file_name.encode(\"utf-8\")) #接收对方发送过来的数据，最大接收1024个字节(1K) recv_data = tcp_client_socket.recv(1024) # print('接收到的数据为:'，recv. data. decodel'utf-8')) #如果接收到数据再创建文件↓否则不创建 if recv_data: with open(\"[接收]\"+file_name, \"wb\") as f: f.write(recv_data) #关闭套接字 tcp_client_socket. close()if __name__ == \"__main__\": main() tcp的3次握手tcp的4次挥手tcp长连接和短连接wireshark的使用tcp/ip简介","categories":[{"name":"python","slug":"python","permalink":"https://duvin0512.github.io./categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://duvin0512.github.io./tags/python/"},{"name":"网络编程","slug":"网络编程","permalink":"https://duvin0512.github.io./tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"网络——UDP","slug":"python-socket01","date":"2020-06-23T08:32:08.000Z","updated":"2020-06-29T10:07:14.000Z","comments":true,"path":"2020/06/23/python-socket01/","link":"","permalink":"https://duvin0512.github.io./2020/06/23/python-socket01/","excerpt":"tcp/ip协议介绍 ip地址的分类 端⼝、端⼝号 socket ⭐ udp通信 ⭐ udp聊天器 ⭐","text":"tcp/ip协议介绍 ip地址的分类 端⼝、端⼝号 socket ⭐ udp通信 ⭐ udp聊天器 ⭐ ⽹络通信概述1. 什么是⽹络说明 ⽹络就是⼀种辅助双⽅或者多⽅能够连接在⼀起的⼯具 2. 使⽤⽹络的⽬的为了联通多⽅然后进⾏通信⽤的，即把数据从⼀⽅传递给另外⼀⽅。之前编写的程序都是单机的，即不能和其他电脑上的程序进⾏通信。为了让在不同的电脑上运⾏的软件，之间能够互相传递数据，就需要借助⽹络的功能 ⼩总结 使⽤⽹络能够把多⽅链接在⼀起，然后可以进⾏数据传递 所谓的⽹络编程就是，让在不同的电脑上的软件能够进⾏数据传递，即进程之间的通信 tcp/ip简介1. 计算机⽹络沟通⽤什么不同的计算机只需要能够联⽹（有线⽆线都可以）那么就可以相互进⾏传递数据 计算机都遵守的⽹络通信协议叫做TCP/IP协议 2. TCP/IP协议(族)早期的计算机⽹络，都是由各⼚商⾃⼰规定⼀套协议，IBM、Apple和 Microsoft都有各⾃的⽹络协议，互不兼容 为了把全世界的所有不同类型的计算机都连接起来，就必须规定⼀套全球通⽤的协议，为了实现互联⽹这个⽬标，互联⽹协议簇（Internet Protocol Suite）就是通⽤协议标准。 因为互联⽹协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，⼤家把互联⽹的协议简称TCP/IP协议。 常⽤的⽹络协议如下图所示： 说明： 12⽹际层也称为：⽹络层⽹络接⼝层也称为：链路层 端⼝1. 什么是端⼝端⼝就好⼀个房⼦的⻔，是出⼊这间房⼦的必经之路。 如果⼀个进程需要收发⽹络数据，那么就需要有这样的端⼝.在linux系统中，端⼝可以有65536（2的16次⽅）个之多！既然有这么多，操作系统为了统⼀管理，所以进⾏了编号，这就是端⼝号 2. 端⼝号端⼝是通过端⼝号来标记的，端⼝号只有整数，范围是从0到65535 3. 端⼝是怎样分配的端⼝号不是随意使⽤的，⽽是按照⼀定的规定进⾏分配。 3.1 知名端⼝（Well Known Ports）知名端⼝是众所周知的端⼝号，范围从0到1023 80端⼝分配给HTTP服务 21端⼝分配给FTP服务 可以理解为，⼀些常⽤的功能使⽤的号码是固定的，好⽐电话号码110、 10086、10010⼀样 ⼀般情况下，如果⼀个程序需要使⽤知名端⼝的需要有root权限 3.2 动态端⼝（Dynamic Ports）动态端⼝的范围是从1024到65535 之所以称为动态端⼝，是因为它⼀般不固定分配某种服务，⽽是动态分配。 动态分配是指当⼀个系统进程或应⽤程序进程需要⽹络通信时，它向主机申请⼀个端⼝，主机从可⽤的端⼝号中分配⼀个供它使⽤。 当这个进程关闭时，同时也就释放了所占⽤的端⼝号。 3.3 怎样查看端⼝?⽤“netstat－an”查看端⼝状态 4. ⼩总结⼀台拥有IP地址的主机可以提供许多服务，⽐如HTTP（万维⽹服务）、FTP（⽂件传输）、SMTP（电⼦邮件）等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的⽹络服务呢？显然不能只靠IP地址，因为IP地址与⽹络服务的关系是⼀对多的关系。 实际上是通过“IP地址+端⼝号”来区分不同的服务的。需要注意的是，端⼝并不是⼀⼀对应的。⽐如你的电脑作为客户机访问⼀台WWW服务器时，WWW服务器使⽤“80”端⼝与你的电脑通信，但你的电脑则可能使⽤“3457”这样的端⼝。 ip地址1. ip地址的作⽤ip地址：⽤来在⽹络中标记⼀台电脑的⼀串数字，⽐如192.168.1.1；在本地局域⽹上是惟⼀的。 2. ip地址的分类每⼀个IP地址包括两部分：⽹络地址和主机地址 2.1 A类IP地址⼀个A类IP地址由1字节的⽹络地址和3字节主机地址组成，⽹络地址的最⾼位必须是“0”， 地址范围1.0.0.1-126.255.255.254 ⼆进制表示为：00000001 00000000 00000000 00000001 - 01111110 11111111 11111111 11111110 可⽤的A类⽹络有126个，每个⽹络能容纳1677214个主机 2.2 B类IP地址⼀个B类IP地址由2个字节的⽹络地址和2个字节的主机地址组成，⽹络地址 的最⾼位必须是“10”， 地址范围128.1.0.1-191.255.255.254 ⼆进制表示为：10000000 00000001 00000000 00000001 - 10111111 11111111 11111111 11111110 可⽤的B类⽹络有16384个，每个⽹络能容纳65534主机 2.3 C类IP地址⼀个C类IP地址由3字节的⽹络地址和1字节的主机地址组成，⽹络地址的最 ⾼位必须是“110” 范围192.0.1.1-223.255.255.254 ⼆进制表示为：11000000 00000000 00000001 00000001 - 11011111 11111111 11111110 11111110 C类⽹络可达2097152个，每个⽹络能容纳254个主机 2.4 D类地址⽤于多点⼴播D类IP地址第⼀个字节以“1110”开始，它是⼀个专⻔保留的地址。 它并不指向特定的⽹络，⽬前这⼀类地址被⽤在多点⼴播（Multicast）中 多点⼴播地址⽤来⼀次寻址⼀组计算机 地址范围224.0.0.1-239.255.255.254 2.5 E类IP地址以“1111”开始，为将来使⽤保留 E类地址保留，仅作实验和开发⽤ 2.6 私有ip在这么多⽹络IP中，国际规定有⼀部分IP地址是⽤于我们的局域⽹使⽤，也就是属于私⽹IP，不在公⽹中使⽤的，它们的范围是： 1234510.0.0.0～10.255.255.255172.16.0.0～172.31.255.255192.168.0.0～192.168.255.255 2.7 注意IP地址127．0．0．1~127．255．255．255⽤于回路测试， 如：127.0.0.1可以代表本机IP地址，⽤http://127.0.0.1就可以测试本机 中配置的Web服务器。 ⼦⽹掩码要想理解什么是⼦⽹掩码，就不能不了解IP地址的构成。互联⽹是由许多⼩型⽹络构成的，每个⽹络上都有许多主机，这样便构成了⼀个有层次的结构。IP地址在设计时就考虑到地址分配的层次特点，将每个IP地址都分割成⽹络号和主机号两部分，以便于IP地址的寻址操作。 如果不指定，就不知道哪些位是⽹络号、哪些是主机号，这就需要通过⼦⽹掩码来实现。 ⼦⽹掩码不能单独存在，它必须结合IP地址⼀起使⽤。 ⼦⽹掩码只有⼀个作⽤，就是将某个IP地址划分成⽹络地址和主机地址两部分 ⼦⽹掩码的设定必须遵循⼀定的规则。 与IP地址相同，⼦⽹掩码的⻓度也是32位， 左边是⽹络位，⽤⼆进制数字“1”表示； 右边是主机位，⽤⼆进制数字“0”表示。 假设IP地址为“192.168.1.1”⼦⽹掩码为“255.255.255.0”。 1234其中，“1”有24个，代表与此相对应的IP地址左边24位是⽹络号；“0”有8个，代表与此相对应的IP地址右边8位是主机号。这样，⼦⽹掩码就确定了⼀个IP地址的32位⼆进制数字中哪些是⽹络号、哪些是主机号。这对于采⽤TCP&#x2F;IP协议的⽹络来说⾮常重要，只有通过⼦⽹掩码，才能表明⼀台主机所在的⼦⽹。 最常⽤的两种⼦⽹掩码 ⼦⽹掩码是“255.255.255.0”的⽹络： 最后⾯⼀个数字可以在0~255范围内任意变化，因此可以提供256个IP地址。但是实际可⽤的IP地址数量是256-2，即254个，因为主机号不能全是“0”或全是“1”。 主机号全为0，表示⽹络号 主机号全为1，表示⽹络⼴播 注意 如果将⼦⽹掩码设置过⼤，也就是说⼦⽹范围扩⼤，那么，根据⼦⽹寻径规则，很可能发往和本地主机不在同⼀⼦⽹内的⽬标主机的数据，会因为错误的判断⽽认为⽬标主机是在同⼀⼦⽹内，那么，数据包将在本⼦⽹内循环，直到超时并抛弃，使数据不能正确到达⽬标主机，导致⽹络传输错误； 如果将⼦⽹掩码设置得过⼩，那么就会将本来属于同⼀⼦⽹内的机器之间的通信当做是跨⼦⽹传输，数据包都交给缺省⽹关处理，这样势必增加缺省⽹关(⽂章下⽅有解释)的负担，造成⽹络效率下降。 因此，⼦⽹掩码应该根据⽹络的规模进⾏设置。如果⼀个⽹络的规模不超过254台电脑，采⽤“255.255.255.0”作为⼦⽹掩码就可以了，现在⼤多数局域⽹都不会超过这个数字，因此“255.255.255.0”是最常⽤的IP地址⼦⽹掩码；假如在⼀所⼤学具有1500多台电脑，这种规模的局域⽹可以使⽤“255.255.0.0”。 socket简介1. 本地的进程间通信（IPC）有很多种⽅式，例 如 队列 同步（互斥锁、条件变量等） 以上通信⽅式都是在⼀台机器上不同进程之间的通信⽅式 2. ⽹络中进程之间如何通信⾸要解决的问题是如何唯⼀标识⼀个进程，否则通信⽆从谈起！ 在本地可以通过进程PID来唯⼀标识⼀个进程，但是在⽹络中这是⾏不通的。 其实TCP/IP协议族已经帮我们解决了这个问题，⽹络层的“ip地址”可以唯⼀ 标识⽹络中的主机，⽽传输层的“协议+端⼝”可以唯⼀标识主机中的应⽤程序（进程）。 这样利⽤ip地址，协议，端⼝就可以标识⽹络的进程了，⽹络中的进程通信 就可以利⽤这个标志与其它进程进⾏交互 3. 什么是socketsocket(简称套接字)是进程间通信的⼀种⽅式，它与其他进程间通信的⼀个主要不同是： 它能实现不同主机间的进程间通信，我们⽹络上各种各样的服务⼤多都是基于Socket来完成通信的 例如浏览⽹⻚、QQ聊天、收发email等等 4. 创建socket在Python中使⽤socket模块的函数socket就可以完成： 1socket.socket(AddressFamily,Type) 说明函数socket.socket创建⼀个socket，返回该socket的描述符，该函数带有两个参数： Address Family：可以选择AF_INET（⽤于Internet进程间通信）或者 AF_UNIX（⽤于同⼀台机器进程间通信）,实际⼯作中常⽤AF_INET Type：套接字类型，可以是SOCK_STREAM（流式套接字，主要⽤于 TCP 协议）或者 SOCK_DGRAM（数据报套接字，主要⽤于UDP协议） 1234//创建⼀个tcp socket（tcp套接字）import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)print 'Socket Created' 1234//创建⼀个udp socket（udp套接字）import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)print 'Socket Created' UDP介绍UDP————⽤户数据报协议，是⼀个⽆连接的简单的⾯向数据报的运输层协议。UDP不提供可靠性，它只是把应⽤程序传给IP层的数据报发送出去，但是并不能保证它们能到达⽬的地。由于UDP在传输数据报前不⽤在客户和服务器之间建⽴⼀个连接，且没有超时重发等机制，故⽽传输速度很快。 UDP是⼀种⾯向⽆连接的协议，每个数据报都是⼀个独⽴的信息，包括完整的源地址或⽬的地址，它在⽹络上以任何可能的路径传往⽬的地，因此能否到达⽬的地，到达⽬的地的时间以及内容的正确性都是不能被保证的。 UDP特点UDP是⾯向⽆连接的通讯协议，UDP数据包括⽬的端⼝号和源端⼝号信息， 由于通讯不需要连接，所以可以实现⼴播发送。UDP传输数据时有⼤⼩限 制，每个被传输的数据报必须限定在64KB之内。UDP是⼀个不可靠的协 议，发送⽅所发送的数据报并不⼀定以相同的次序到达接收⽅。 【适⽤情况】 UDP是⾯向消息的协议，通信时不需要建⽴连接，数据的传输⾃然是不可靠 的，UDP⼀般⽤于多点通信和实时的数据业务，⽐如 语⾳⼴播 视频 QQ TFTP(简单⽂件传送) SNMP(简单⽹络管理协议) RIP(路由信息协议，如报告股票市场，航空信息） DNS(域名解释） 注重速度流畅 UDP操作简单，⽽且仅需要较少的监护，因此通常⽤于局域⽹⾼可靠性的分散系统中client/server应⽤程序。例如视频会议系统，并不要求⾳频视频数据绝对的正确，只要保证连贯性就可以了，这种情况下显然使⽤UDP会更合理⼀些。 udp⽹络程序-发送数据创建⼀个udp客户端程序的流程是简单，具体步骤如下： 创建客户端套接字 发送数据 关闭套接字 代码如下： 1234567891011121314151617#coding=utf-8from socket import *#1. 创建套接字udpSocket = socket(AF_INET, SOCK_DGRAM)#2. 准备接收⽅的地址sendAddr = ('192.168.0.102', 8080)#3. 从键盘获取数据sendData = input(\"请输⼊要发送的数据:\")#4. 发送数据到指定的电脑上udpSocket.sendto(sendData, sendAddr)#5. 关闭套接字udpSocket.close() 运⾏现象：在Ubuntu中运⾏脚本： 在windows中运⾏“⽹络调试助⼿”： 带有推出功能的循环发送数据123456789101112131415161718192021import socket# 1.创建一个udp套接字udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)while True: # 2.从键盘获取数据 send_data = input(\"请输入要发送的数据: \") #如果输入的数据是exit,那么就退出程序 if send_data ==\"exit\": break #可以使用套接字收发数据 # udp_socket.sendto(\"hahahah\",对方的ip以及port) # udp_socket.sendto( b\"hahahah------1----\", (\"192. 168.0.102\", 8080)) udp_socket.sendto(send_data.encode(\"utf-8\"), (\"192.168.0.102\", 8080))# 3.关闭套接字udp_socket.close() udp⽹络程序-接收数据创建⼀个udp客户端程序的流程是简单，具体步骤如下： 创建客户端套接字 绑定本地自己的信息（ip和port） 接收数据 关闭套接字 代码如下： 1234567891011121314151617181920212223#coding=utf-8from socket import *#1. 创建套接字udp_socket = socket(AF_INET, SOCK_DGRAM)# 2.绑定本地的相关信息local_addr = (\"\", 7788)udp_socket.bind(local_addr)#3. 接收数据recv_data = udp_socket.recvfrom(1024)# recv_data这个变量中存储的是一个元组(接收到的数据，(发送方的ip, port))recv_msg = recv_data[0] # 存储接收的数据send_addr = recv_data[i] # 存储发送方的地址信息# 打印接收到的数据# print(recv_ data )# print(\"%s:%s\" % (str(send_addr), recv_msg.decode(\"utf-8\")))print(\"%s:%s\" % (str(send_addr), recv_msg.decode(\"gbk\")))# 4.关闭套接字udp_socket.close() 运⾏现象：在Ubuntu中运⾏脚本： 在windows中运⾏“⽹络调试助⼿”： 循环接收并显示数据12345678910111213141516171819202122232425#coding=utf-8from socket import *#1. 创建套接字udp_socket = socket(AF_INET, SOCK_DGRAM)# 2.绑定本地的相关信息local_addr = (\"\", 7788)udp_socket.bind(local_addr)while True: #3. 接收数据 recv_data = udp_socket.recvfrom(1024) # recv_data这个变量中存储的是一个元组(接收到的数据，(发送方的ip, port)) recv_msg = recv_data[0] # 存储接收的数据 send_addr = recv_data[i] # 存储发送方的地址信息 # 4.打印接收到的数据 # print(recv_ data ) # print(\"%s:%s\" % (str(send_addr), recv_msg.decode(\"utf-8\"))) print(\"%s:%s\" % (str(send_addr), recv_msg.decode(\"gbk\")))#5. 关闭套接字udp_socket.close() udp⽹络程序-端⼝问题会变的端⼝号重新运⾏多次脚本，然后在“⽹络调试助⼿”中，看到的现象如下： 说明： 每重新运⾏⼀次⽹络程序，上图中红圈中的数字，不⼀样的原因在于，这个数字标识这个⽹络程序，当重新运⾏时，如果没有确定到底⽤哪个，系统默认会随机分配 记住⼀点：这个⽹络程序在运⾏的过程中，这个就唯⼀标识这个程序，所以如果其他电脑上的⽹络程序如果想要向此程序发送数据，那么就需要向这个数字（即端⼝）标识的程序发送即可 使用同一个套接字收发数据1234567891011121314151617181920212223import socket#创建一个udp套接字udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)#获取对方的ip/portdest_ip = input(\"请输入对方的ip:\")dest_port = int(input(\"请输入对方的port:\"))#从键盘获取数据send_data = input(\"请输入要发送的数据: \")#可以使用套接字收发数据# udp_socket.sendto(\"hahahah\", 对方的ip以及port)# udp_socket.sendto(b\"hahahah1----\"，(\"192.168.0.102\", 8080))# udp_socket.sendto(send_data.encode(\"utf-8\"), (\"192.168.0.102\", 8080))udp_socket.sendto(send_data.encode(\"utf-8\"), (dest_ip, dest_port))#接收回送过来的数据recv_data = udp_socket.recvfrom(1024)print(recv_data)#关闭套接字udp_socket.close() 3. 总结 ⼀个udp⽹络程序，可以不绑定，此时操作系统会随机进⾏分配⼀个端⼝，如果重新运⾏次程序端⼝可能会发⽣变化 ⼀个udp⽹络程序，也可以绑定信息（ip地址，端⼝号），如果绑定成功，那么操作系统⽤这个端⼝号来进⾏区别收到的⽹络数据是否是此进程的 udp⽹络通信过程 udp总结1. udp是TCP/IP协议族中的⼀种协议能够完成不同机器上的程序间的数据通信2. udp服务器、客户端 udp的服务器和客户端的区分：往往是通过请求服务和提供服务来进⾏区分 请求服务的⼀⽅称为：客户端 提供服务的⼀⽅称为：服务器 3. udp绑定问题 ⼀般情况下，服务器端，需要绑定端⼝，⽬的是为了让其他的客户端能够正确发送到此进程 客户端，⼀般不需要绑定，⽽是让操作系统随机分配，这样就不会因为 需要绑定的端⼝被占⽤⽽导致程序⽆法运⾏的情况 udp聊天器说明 在一个电脑中编写1个程序，有2个功能 1.获取键盘数据，并将其发送给对方 2.接收数据并显示 并且功能数据进行选择以上的2个功能调用 要求 实现上述程序 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041import socketdef send_msg(udp_socket): \"\"\"发送消息\"\"\" #获取要发送的内容 dest_ip = input(\"请输入对方的ip:\") dest_port = int(input(\"请输入对方的port:\" )) send_data = input(\"请输入要发送的消息:\") udp_socket.sendto(send_data.encode(\"utf-8\"), (dest_ip, dest_port))def recv_msg(udp_socket): \"\"\"接收数据\"\"\" recv_data = udp_socket.recvfrom(1024) print(\"%s:%s\" % (str(recv_data[1]), recv_data[0].decode(\"utf-8\")))def main(): #创建套接字 udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) #绑定信息 udp_socket.bind((\"\", 7788)) #循环循环来进行处理事情 while True: print(\"----Xxx聊天器-----\") print(\"1:发送消息\") print(\"2:接收消息\") print(\"0:退出系统\") op = input(\"请输入功能:\") if op==\"1\": #发送 send_msg(udp_socket) elif op == \"2\": #接收并显示 recv_msg(udp_socket) elif op == \"0\" : break else: print(\"输入有误请重新输入...\")if nane__ == \"__main__\": main( )","categories":[{"name":"python","slug":"python","permalink":"https://duvin0512.github.io./categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://duvin0512.github.io./tags/python/"},{"name":"网络编程","slug":"网络编程","permalink":"https://duvin0512.github.io./tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"hexo博客上传本地图片","slug":"blog_1","date":"2020-06-18T06:19:45.000Z","updated":"2020-06-18T07:10:44.000Z","comments":true,"path":"2020/06/18/blog_1/","link":"","permalink":"https://duvin0512.github.io./2020/06/18/blog_1/","excerpt":"文章中如何插入图片","text":"文章中如何插入图片 之前在写博客时不是很明确本地图片的上传方式。一直是将图片储存在有道云笔记中生成图片链接插入博客中。但之后发现每次刚部署发布的时候是成功的，可以显示图片。但是下一次打开的时候图片还是显示崩溃，之后发现可能是有道云笔记里的图片地址是变化的。 之后在网上找到一种方法： 在博客文件夹下找到source文件夹，在source文件夹下新建一个images文件夹，将图片统一放在source/images文件夹中，之后通过markdown语法访问它们。 之后通过hexo g,hexo d命令部署上传,图片就可以上传正常显示了。","categories":[{"name":"blog","slug":"blog","permalink":"https://duvin0512.github.io./categories/blog/"}],"tags":[{"name":"blog配置","slug":"blog配置","permalink":"https://duvin0512.github.io./tags/blog%E9%85%8D%E7%BD%AE/"}]},{"title":"数据库大复习","slug":"Database21","date":"2020-06-14T15:53:42.000Z","updated":"2020-06-14T16:11:00.000Z","comments":true,"path":"2020/06/14/Database21/","link":"","permalink":"https://duvin0512.github.io./2020/06/14/Database21/","excerpt":"目录","text":"目录 目录一、为什么要学习数据库二、数据库的相关概念 DBMS DB SQL 三、数据库存储数据的特点四、初始MySQL MySQL产品的介绍 MySQL产品的安装 ★ MySQL服务的启动和停止 ★ MySQL服务的登录和退出 ★ MySQL的常见命令和语法规范 五、DQL语言的学习 ★ 基础查询 ★ 条件查询 ★ 排序查询 ★ 常见函数 ★ 分组函数 ★ 分组查询 ★ 连接查询 ★ 子查询 √ 分页查询 ★ union联合查询 √ 六、DML语言的学习 ★ 插入语句 修改语句 删除语句 七、DDL语言的学习 库和表的管理 √ 常见数据类型介绍 √ 常见约束 √ 八、TCL语言的学习 事务和事务处理 九、视图的讲解 √十、变量十一、存储过程和函数十二、流程控制结构","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"流程控制结构","slug":"Database20","date":"2020-06-13T06:05:04.000Z","updated":"2020-06-13T06:21:20.000Z","comments":true,"path":"2020/06/13/Database20/","link":"","permalink":"https://duvin0512.github.io./2020/06/13/Database20/","excerpt":"顺序结构 分支结构 循环结构","text":"顺序结构 分支结构 循环结构 流程控制结构顺序、分支、循环 一、分支结构1.if函数语法： if(条件,值1，值2) 功能： 实现双分支 应用在begin end中或外面 2.case结构语法： 1234567#情况1：类似于switchcase 变量或表达式when 值1 then 语句1;when 值2 then 语句2;...else 语句n;end 1234567#情况2：casewhen 条件1 then 语句1;when 条件2 then 语句2;...else 语句n;end 应用在begin end 中或外面 3.if结构语法： 12345if 条件1 then 语句1;elseif 条件2 then 语句2;....else 语句n;end if; 功能： 类似于多重if 只能应用在begin end 中 12345678910111213141516#案例1：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回DCREATE FUNCTION test_if(score FLOAT) RETURNS CHARBEGIN DECLARE ch CHAR DEFAULT 'A'; IF score&gt;90 THEN SET ch='A'; ELSE IF score&gt;80 THEN SET ch='B'; ELSE IF score&gt;60 THEN SET ch='C'; ELSE SET ch='D'; END IF; RETURN ch; END $SELECT test_if(87)$ 12345678910111213#案例2：创建存储过程，如果工资&lt;2000,则删除，如果5000&gt;工资&gt;2000,则涨工资1000，否则涨工资500CREATE PROCEDURE test_if_pro(IN sal DOUBLE)BEGIN IF sal&lt;2000 THEN DELETE FROM employees WHERE employees.salary=sal; ELSEIF sal&gt;=2000 AND sal&lt;5000 THEN UPDATE employees SET salary=salary+1000 WHERE employees.`salary`=sal; ELSE UPDATE employees SET salary=salary+500 WHERE employees.`salary`=sal; END IF; END $CALL test_if_pro(2100)$ 1234567891011121314151617#案例1：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回DCREATE FUNCTION test_case(score FLOAT) RETURNS CHARBEGIN DECLARE ch CHAR DEFAULT 'A'; CASE WHEN score&gt;90 THEN SET ch='A'; WHEN score&gt;80 THEN SET ch='B'; WHEN score&gt;60 THEN SET ch='C'; ELSE SET ch='D'; END CASE; RETURN ch;END $SELECT test_case(56)$ 二、循环结构分类： while、loop、repeat 循环控制： iterate类似于 continue，继续，结束本次循环，继续下一次 leave 类似于 break，跳出，结束当前所在的循环 1.while语法： 123【标签:】while 循环条件 do 循环体;end while【 标签】; 联想： 1234while(循环条件)&#123; 循环体;&#125; 2.loop语法： 123【标签:】loop 循环体;end loop 【标签】; 可以用来模拟简单的死循环 3.repeat语法： 1234【标签：】repeat 循环体;until 结束循环的条件end repeat 【标签】; 12345678910111213141516171819202122232425262728#1.没有添加循环控制语句#案例：批量插入，根据次数插入到admin表中多条记录DROP PROCEDURE pro_while1$CREATE PROCEDURE pro_while1(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 1; WHILE i&lt;=insertCount DO INSERT INTO admin(username,`password`) VALUES(CONCAT('Rose',i),'666'); SET i=i+1; END WHILE; END $CALL pro_while1(100)$/*int i=1;while(i&lt;=insertcount)&#123; //插入 i++;&#125;*/ 123456789101112131415161718#2.添加leave语句#案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止TRUNCATE TABLE admin$DROP PROCEDURE test_while1$CREATE PROCEDURE test_while1(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 1; a:WHILE i&lt;=insertCount DO INSERT INTO admin(username,`password`) VALUES(CONCAT('xiaohua',i),'0000'); IF i&gt;=20 THEN LEAVE a; END IF; SET i=i+1; END WHILE a;END $CALL test_while1(100)$ 12345678910111213141516171819202122232425262728293031323334#3.添加iterate语句#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次TRUNCATE TABLE admin$DROP PROCEDURE test_while1$CREATE PROCEDURE test_while1(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 0; a:WHILE i&lt;=insertCount DO SET i=i+1; IF MOD(i,2)!=0 THEN ITERATE a; END IF; INSERT INTO admin(username,`password`) VALUES(CONCAT('xiaohua',i),'0000'); END WHILE a;END $CALL test_while1(100)$/*int i=0;while(i&lt;=insertCount)&#123; i++; if(i%2==0)&#123; continue; &#125; 插入 &#125;*/","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"存储过程和函数","slug":"Database19","date":"2020-06-13T05:39:10.000Z","updated":"2020-06-13T06:09:42.000Z","comments":true,"path":"2020/06/13/Database19/","link":"","permalink":"https://duvin0512.github.io./2020/06/13/Database19/","excerpt":"存储过程 函数","text":"存储过程 函数 存储过程和函数存储过程和函数：类似于java中的方法 好处： 提高代码的重用性 简化操作 存储过程含义： 一组预先编译好的SQL语句的集合，理解成批处理语句 提高代码的重用性 简化操作 减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率 一、创建语法12345CREATE PROCEDURE 存储过程名(参数列表)BEGIN 存储过程体（一组合法的SQL语句）END 注意： 参数列表包含三部分 参数模式 参数名 参数类型 举例： in stuname varchar(20) 参数模式： in：该参数可以作为输入，也就是该参数需要调用方传入值 out：该参数可以作为输出，也就是该参数可以作为返回值 inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值 如果存储过程体仅仅只有一句话，begin end可以省略 存储过程体中的每条sql语句的结尾要求必须加分号。 存储过程的结尾可以使用 delimiter 重新设置 语法： delimiter 结束标记 案例： delimiter $ 二、调用语法CALL 存储过程名(实参列表); 1.空参列表1234567891011121314#案例：插入到admin表中五条记录SELECT * FROM admin;DELIMITER $CREATE PROCEDURE myp1()BEGIN INSERT INTO admin(username,`password`) VALUES('john1','0000'),('lily','0000'),('rose','0000'),('jack','0000'),('tom','0000');END $#调用CALL myp1()$ 2.创建带in模式参数的存储过程1234567891011121314#案例1：创建存储过程实现 根据女神名，查询对应的男神信息CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))BEGIN SELECT bo.* FROM boys bo RIGHT JOIN beauty b ON bo.id = b.boyfriend_id WHERE b.name=beautyName; END $#调用CALL myp2('柳岩')$ 12345678910111213141516#案例2 ：创建存储过程实现，用户是否登录成功CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))BEGIN DECLARE result INT DEFAULT 0;#声明并初始化 SELECT COUNT(*) INTO result#赋值 FROM admin WHERE admin.username = username AND admin.password = PASSWORD; SELECT IF(result&gt;0,'成功','失败');#使用END $#调用CALL myp3('张飞','8888')$ 3.创建out 模式参数的存储过程1234567891011#案例1：根据输入的女神名，返回对应的男神名CREATE PROCEDURE myp6(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))BEGIN SELECT bo.boyname INTO boyname FROM boys bo RIGHT JOIN beauty b ON b.boyfriend_id = bo.id WHERE b.name=beautyName ; END $ 12345678910111213141516#案例2：根据输入的女神名，返回对应的男神名和魅力值CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) BEGIN SELECT boys.boyname ,boys.usercp INTO boyname,usercp FROM boys RIGHT JOIN beauty b ON b.boyfriend_id = boys.id WHERE b.name=beautyName ; END $#调用CALL myp7('小昭',@name,@cp)$SELECT @name,@cp$ 4.创建带inout模式参数的存储过程12345678910111213#案例1：传入a和b两个值，最终a和b都翻倍并返回CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)BEGIN SET a=a*2; SET b=b*2;END $#调用SET @m=10$SET @n=20$CALL myp8(@m,@n)$SELECT @m,@n$ 三、删除存储过程语法： drop procedure 存储过程名 12DROP PROCEDURE p1;DROP PROCEDURE p2,p3;#× 四、查看存储过程的信息12DESC myp2;×SHOW CREATE PROCEDURE myp2; 函数含义： 一组预先编译好的SQL语句的集合，理解成批处理语句 提高代码的重用性 简化操作 减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率 区别： 存储过程： 可以有0个返回，也可以有多个返回，适合做批量插入、批量更新 函数： 有且仅有1个返回，适合做处理数据后返回一个结果 一、创建语法1234CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型BEGIN 函数体END 注意： 参数列表 包含两部分： 参数名 参数类型 函数体：肯定会有return语句，如果没有会报错 如果return语句没有放在函数体的最后也不报错，但不建议 return 值; 函数体中仅有一句话，则可以省略begin end 使用 delimiter语句设置结束标记 二、调用语法1SELECT 函数名(参数列表) 1.无参有返回123456789101112#案例：返回公司的员工个数CREATE FUNCTION myf1() RETURNS INTBEGIN DECLARE c INT DEFAULT 0;#定义局部变量 SELECT COUNT(*) INTO c#赋值 FROM employees; RETURN c; END $SELECT myf1()$ 2.有参有返回12345678910111213#案例1：根据员工名，返回它的工资CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLEBEGIN SET @sal=0;#定义用户变量 SELECT salary INTO @sal #赋值 FROM employees WHERE last_name = empName; RETURN @sal;END $SELECT myf2('k_ing') $ 12345678910111213#案例2：根据部门名，返回该部门的平均工资CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLEBEGIN DECLARE sal DOUBLE ; SELECT AVG(salary) INTO sal FROM employees e JOIN departments d ON e.department_id = d.department_id WHERE d.department_name=deptName; RETURN sal;END $SELECT myf3('IT')$ 三、查看函数1SHOW CREATE FUNCTION myf3; 四、删除函数1DROP FUNCTION myf3; 1234567891011#案例#一、创建函数，实现传入两个float，返回二者之和CREATE FUNCTION test_fun1(num1 FLOAT,num2 FLOAT) RETURNS FLOATBEGIN DECLARE SUM FLOAT DEFAULT 0; SET SUM=num1+num2; RETURN SUM;END $SELECT test_fun1(1,2)$","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"变量","slug":"Database18","date":"2020-06-13T05:13:21.000Z","updated":"2020-06-13T05:35:20.000Z","comments":true,"path":"2020/06/13/Database18/","link":"","permalink":"https://duvin0512.github.io./2020/06/13/Database18/","excerpt":"系统变量 自定义变量","text":"系统变量 自定义变量 变量 系统变量： 全局变量 会话变量 自定义变量： 用户变量 局部变量 一、系统变量说明： 变量由系统定义，不是用户定义，属于服务器层面 注意： 全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别 使用步骤： 查看所有系统变量 show global|【session】variables; 查看满足条件的部分系统变量 show global|【session】 variables like &#39;%char%&#39;; 查看指定的系统变量的值 select @@global|【session】系统变量名; 为某个系统变量赋值 方式一： set global|【session】系统变量名=值; 方式二： set @@global|【session】系统变量名=值; 1 全局变量作用域： 针对于所有会话（连接）有效，但不能跨重启 123456789#①查看所有全局变量SHOW GLOBAL VARIABLES;#②查看满足条件的部分系统变量SHOW GLOBAL VARIABLES LIKE '%char%';#③查看指定的系统变量的值SELECT @@global.autocommit;#④为某个系统变量赋值SET @@global.autocommit=0;SET GLOBAL autocommit=0; 2 会话变量作用域 针对于当前会话（连接）有效 12345678910#①查看所有会话变量SHOW SESSION VARIABLES;#②查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE '%char%';#③查看指定的会话变量的值SELECT @@autocommit;SELECT @@session.tx_isolation;#④为某个会话变量赋值SET @@session.tx_isolation='read-uncommitted';SET SESSION tx_isolation='read-committed'; 二、自定义变量说明： 变量由用户自定义，而不是系统提供的 使用步骤： 声明 赋值 使用（查看、比较、运算等） 1 用户变量作用域： 针对于当前会话（连接）有效，作用域同于会话变量 1234567891011121314151617#赋值操作符：=或:=#①声明并初始化SET @变量名=值;SET @变量名:=值;SELECT @变量名:=值;#②赋值（更新变量的值）#方式一： SET @变量名=值; SET @变量名:=值; SELECT @变量名:=值;#方式二： SELECT 字段 INTO @变量名 FROM 表;#③使用（查看变量的值）SELECT @变量名; 2 局部变量作用域： 仅仅在定义它的begin end块中有效 应用在 begin end中的第一句话 12345678910111213141516#①声明DECLARE 变量名 类型;DECLARE 变量名 类型 【DEFAULT 值】;#②赋值（更新变量的值）#方式一： SET 局部变量名=值; SET 局部变量名:=值; SELECT 局部变量名:=值;#方式二： SELECT 字段 INTO 具备变量名 FROM 表;#③使用（查看变量的值）SELECT 局部变量名; 1234567891011121314#案例：声明两个变量，求和并打印#用户变量SET @m=1;SET @n=1;SET @sum=@m+@n;SELECT @sum;#局部变量DECLARE m INT DEFAULT 1;DECLARE n INT DEFAULT 1;DECLARE SUM INT;SET SUM=m+n;SELECT SUM; 用户变量和局部变量的对比 名称 作用域 定义位置 语法 用户变量 当前会话 会话的任何地方 加@符号，不用指定类型 局部变量 定义它的BEGIN END中 BEGIN END的第一句话 一般不用加@,需要指定类型","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"视图","slug":"Database17","date":"2020-06-13T04:52:03.000Z","updated":"2020-06-13T05:12:30.000Z","comments":true,"path":"2020/06/13/Database17/","link":"","permalink":"https://duvin0512.github.io./2020/06/13/Database17/","excerpt":"创建 修改 删除 查看 更新","text":"创建 修改 删除 查看 更新 视图含义： 虚拟表，和普通表一样使用 mysql5.1版本出现的新特性，是通过表动态生成的数据 名称 创建语法的关键字 是否实际占用物理空间 使用 视图 create view 只是保存了sql逻辑 增删改查，只是一般不能增删改 表 create table 保存了数据 增删改查 12345678910111213#案例：查询姓张的学生名和专业名SELECT stuname,majornameFROM stuinfo sINNER JOIN major m ON s.`majorid`= m.`id`WHERE s.`stuname` LIKE '张%';CREATE VIEW v1ASSELECT stuname,majornameFROM stuinfo sINNER JOIN major m ON s.`majorid`= m.`id`;SELECT * FROM v1 WHERE stuname LIKE '张%'; 一、创建视图语法： 123create view 视图名as查询语句; 12345678910111213#1.查询姓名中包含a字符的员工名、部门名和工种信息#①创建CREATE VIEW myv1ASSELECT last_name,department_name,job_titleFROM employees eJOIN departments d ON e.department_id = d.department_idJOIN jobs j ON j.job_id = e.job_id;#②使用SELECT * FROM myv1 WHERE last_name LIKE '%a%'; 1234567891011121314#2.查询各部门的平均工资级别#①创建视图查看每个部门的平均工资CREATE VIEW myv2ASSELECT AVG(salary) ag,department_idFROM employeesGROUP BY department_id;#②使用SELECT myv2.`ag`,g.grade_levelFROM myv2JOIN job_grades gON myv2.`ag` BETWEEN g.`lowest_sal` AND g.`highest_sal`; 123456789101112131415#3.查询平均工资最低的部门信息SELECT * FROM myv2 ORDER BY ag LIMIT 1;#4.查询平均工资最低的部门名和工资CREATE VIEW myv3ASSELECT * FROM myv2 ORDER BY ag LIMIT 1;SELECT d.*,m.agFROM myv3 mJOIN departments dON m.`department_id`=d.`department_id`; 二、视图的修改方式一123create or replace view 视图名as查询语句; 1234567SELECT * FROM myv3CREATE OR REPLACE VIEW myv3ASSELECT AVG(salary),job_idFROM employeesGROUP BY job_id; 方式二语法： 123alter view 视图名as查询语句; 123ALTER VIEW myv3ASSELECT * FROM employees; 三、删除视图语法： 1drop view 视图名,视图名,...; 1DROP VIEW emp_v1,emp_v2,myv3; 四、查看视图123DESC myv3;SHOW CREATE VIEW myv3; 五、视图的更新123456789CREATE OR REPLACE VIEW myv1ASSELECT last_name,email,salary*12*(1+IFNULL(commission_pct,0)) \"annual salary\"FROM employees;CREATE OR REPLACE VIEW myv1ASSELECT last_name,emailFROM employees; 1.插入1INSERT INTO myv1 VALUES('张飞','zf@qq.com'); 2.修改1UPDATE myv1 SET last_name = '张无忌' WHERE last_name='张飞'; 3.删除1DELETE FROM myv1 WHERE last_name = '张无忌'; 具备以下特点的视图不允许更新 123456789101112#①包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union allCREATE OR REPLACE VIEW myv1ASSELECT MAX(salary) m,department_idFROM employeesGROUP BY department_id;SELECT * FROM myv1;#更新UPDATE myv1 SET m=9000 WHERE department_id=10; 12345678910#②常量视图CREATE OR REPLACE VIEW myv2ASSELECT 'john' NAME;SELECT * FROM myv2;#更新UPDATE myv2 SET NAME='lucy'; 1234567891011#③Select中包含子查询CREATE OR REPLACE VIEW myv3ASSELECT department_id,(SELECT MAX(salary) FROM employees) 最高工资FROM departments;#更新SELECT * FROM myv3;UPDATE myv3 SET 最高工资=100000; 1234567891011121314#④joinCREATE OR REPLACE VIEW myv4ASSELECT last_name,department_nameFROM employees eJOIN departments dON e.department_id = d.department_id;#更新SELECT * FROM myv4;UPDATE myv4 SET last_name = '张飞' WHERE last_name='Whalen';INSERT INTO myv4 VALUES('陈真','xxxx'); 1234567891011#⑤from一个不能更新的视图CREATE OR REPLACE VIEW myv5ASSELECT * FROM myv3;#更新SELECT * FROM myv5;UPDATE myv5 SET 最高工资=10000 WHERE department_id=60; 12345678910111213141516#⑥where子句的子查询引用了from子句中的表CREATE OR REPLACE VIEW myv6ASSELECT last_name,email,salaryFROM employeesWHERE employee_id IN( SELECT manager_id FROM employees WHERE manager_id IS NOT NULL);#更新SELECT * FROM myv6;UPDATE myv6 SET salary=10000 WHERE last_name = 'k_ing';","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"TCL语言————事务","slug":"Database16","date":"2020-06-12T17:09:08.000Z","updated":"2020-06-13T15:39:28.000Z","comments":true,"path":"2020/06/13/Database16/","link":"","permalink":"https://duvin0512.github.io./2020/06/13/Database16/","excerpt":"演示事务的使用步骤 演示事务对于delete和truncate的处理的区别 演示savepoint 的使用","text":"演示事务的使用步骤 演示事务对于delete和truncate的处理的区别 演示savepoint 的使用 TCLTransaction Control Language 事务控制语言 事务： 一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。 12345678#案例：转账#张三丰 1000#郭襄 1000update 表 set 张三丰的余额=500 where name='张三丰'意外update 表 set 郭襄的余额=1500 where name='郭襄' 事务的特性： ACID 原子性：一个事务不可再分割，要么都执行要么都不执行 一致性：一个事务执行会使数据从一个一致状态切换到另外一个一致状态 隔离性：一个事务的执行不受其他事务的干扰 持久性：一个事务一旦提交，则会永久的改变数据库的数据. 事务的创建 隐式事务：事务没有明显的开启和结束的标记 比如insert、update、delete语句 delete from 表 where id =1; 显式事务：事务具有明显的开启和结束的标记 前提：必须先设置自动提交功能为禁用 set autocommit=0; 12345678910111213#步骤1：开启事务set autocommit=0;start transaction;可选的#步骤2：编写事务中的sql语句(select insert update delete)语句1;语句2;...#步骤3：结束事务commit;提交事务rollback;回滚事务savepoint 节点名;设置保存点 并发事务 事务的并发问题是如何发生的？ 多个事务 同时 操作 同一个数据库的相同数据时 并发问题都有哪些？ 脏读：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“更新”的数据 不可重复读：一个事务多次读取，结果不一样 幻读：一个事务读取了其他事务还没有提交的数据，只是读到的是 其他事务“插入”的数据 如何解决并发问题 通过设置隔离级别来解决并发问题 隔离级别 事务的隔离级别： 脏读 不可重复读 幻读 read uncommitted √ √ √ read committed × √ √ repeatable read × × √ serializable × × × mysql中默认第三个隔离级别 repeatable read oracle中默认第二个隔离级别 read committed 1234查看隔离级别select @@tx_isolation;设置隔离级别set session|global transaction isolation level 隔离级别; 12345开启事务的语句;update 表 set 张三丰的余额=500 where name='张三丰'update 表 set 郭襄的余额=1500 where name='郭襄'结束事务的语句; 1.演示事务的使用步骤12345678910#开启事务SET autocommit=0;START TRANSACTION;#编写一组事务的语句UPDATE account SET balance = 1000 WHERE username='张无忌';UPDATE account SET balance = 1000 WHERE username='赵敏';#结束事务ROLLBACK;#commit; 2.演示事务对于delete和truncate的处理的区别12345SET autocommit=0;START TRANSACTION;DELETE FROM account;ROLLBACK; 3.演示savepoint 的使用123456SET autocommit=0;START TRANSACTION;DELETE FROM account WHERE id=25;SAVEPOINT a;#设置保存点DELETE FROM account WHERE id=28;ROLLBACK TO a;#回滚到保存点","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"【补充】标识列","slug":"Database15","date":"2020-06-12T16:44:34.000Z","updated":"2020-06-12T17:08:28.000Z","comments":true,"path":"2020/06/13/Database15/","link":"","permalink":"https://duvin0512.github.io./2020/06/13/Database15/","excerpt":"标识列","text":"标识列 标识列又称为自增长列 含义：可以不用手动的插入值，系统提供默认的序列值 特点： 标识列必须和主键搭配吗？不一定，但要求是一个key 一个表可以有几个标识列？至多一个！ 标识列的类型只能是数值型 标识列可以通过 SET auto_increment_increment=3;设置步长 可以通过 手动插入值，设置起始值 一、创建表时设置标识列1234567891011121314151617181920DROP TABLE IF EXISTS tab_identity;CREATE TABLE tab_identity( id INT , NAME FLOAT UNIQUE AUTO_INCREMENT, seat INT);TRUNCATE TABLE tab_identity;INSERT INTO tab_identity(id,NAME) VALUES(NULL,'john');INSERT INTO tab_identity(NAME) VALUES('lucy');SELECT * FROM tab_identity;SHOW VARIABLES LIKE '%auto_increment%';SET auto_increment_increment=3;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"DDL语言————常见约束","slug":"Database14","date":"2020-06-12T16:28:33.000Z","updated":"2020-06-13T15:48:52.000Z","comments":true,"path":"2020/06/13/Database14/","link":"","permalink":"https://duvin0512.github.io./2020/06/13/Database14/","excerpt":"NOT NULL DEFAULT PRIMARY KEY UNIQUE CHECK FOREIGN KEY","text":"NOT NULL DEFAULT PRIMARY KEY UNIQUE CHECK FOREIGN KEY 常见约束含义： 一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性 分类：六大约束 NOT NULL：非空，用于保证该字段的值不能为空 比如姓名、学号等 DEFAULT:默认，用于保证该字段有默认值 比如性别 PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空 比如学号、员工编号等 UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空 比如座位号 CHECK:检查约束【mysql中不支持】 比如年龄、性别 FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值 在从表添加外键约束，用于引用主表中某列的值 比如学生表的专业编号，员工表的部门编号，员工表的工种编号 添加约束的时机： 创建表时 修改表时 约束的添加分类： 列级约束： 六大约束语法上都支持，但外键约束没有效果 表级约束： 除了非空、默认，其他的都支持 主键和唯一的大对比： 名称 保证唯一性 是否允许为空 一个表中可以有多少个 是否允许组合 主键 √ × 至多有1个 √，但不推荐 外键 唯一 √ √ 可以有多个 区别： ①、一个表至多有一个主键，但可以有多个唯一 ②、主键不允许为空，唯一可以为空 相同点 都具有唯一性 都支持组合键，但不推荐 外键： 要求在从表设置外键关系 从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求 主表的关联列必须是一个key（一般是主键或唯一） 插入数据时，先插入主表，再插入从表 删除数据时，先删除从表，再删除主表 可以通过以下两种方式来删除主表的记录 12345#方式一：级联删除ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;#方式二：级联置空ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL; 123456CREATE TABLE 表名( 字段名 字段类型 列级约束, 字段名 字段类型, 表级约束) 一、创建表时添加约束1.添加列级约束语法： 直接在字段名和类型后面追加 约束类型即可。 只支持：默认、非空、主键、唯一 1234567891011121314151617181920USE students;DROP TABLE stuinfo;CREATE TABLE stuinfo( id INT PRIMARY KEY,#主键 stuName VARCHAR(20) NOT NULL UNIQUE,#非空 gender CHAR(1) CHECK(gender='男' OR gender ='女'),#检查 seat INT UNIQUE,#唯一 age INT DEFAULT 18,#默认约束 majorId INT REFERENCES major(id)#外键);CREATE TABLE major( id INT PRIMARY KEY, majorName VARCHAR(20));#查看stuinfo中的所有索引，包括主键、外键、唯一SHOW INDEX FROM stuinfo; 2.添加表级约束语法：在各个字段的最下面 【constraint 约束名】 约束类型(字段名) 123456789101112131415DROP TABLE IF EXISTS stuinfo;CREATE TABLE stuinfo( id INT, stuname VARCHAR(20), gender CHAR(1), seat INT, age INT, majorid INT, CONSTRAINT pk PRIMARY KEY(id),#主键 CONSTRAINT uq UNIQUE(seat),#唯一键 CONSTRAINT ck CHECK(gender ='男' OR gender = '女'),#检查 CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键 ); 123456789101112#通用的写法：★CREATE TABLE IF NOT EXISTS stuinfo( id INT PRIMARY KEY, stuname VARCHAR(20), sex CHAR(1), age INT DEFAULT 18, seat INT UNIQUE, majorid INT, CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)); 二、修改表时添加约束1、添加列级约束1alter table 表名 modify column 字段名 字段类型 新约束; 2、添加表级约束1alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】; 1234567891011121314151617181920212223242526272829303132333435DROP TABLE IF EXISTS stuinfo;CREATE TABLE stuinfo( id INT, stuname VARCHAR(20), gender CHAR(1), seat INT, age INT, majorid INT)#1.添加非空约束ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NOT NULL;#2.添加默认约束ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;#3.添加主键#①列级约束ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;#②表级约束ALTER TABLE stuinfo ADD PRIMARY KEY(id);#4.添加唯一#①列级约束ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;#②表级约束ALTER TABLE stuinfo ADD UNIQUE(seat);#5.添加外键ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); 三、修改表时删除约束1.删除非空约束1ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL; 2.删除默认约束1ALTER TABLE stuinfo MODIFY COLUMN age INT ; 3.删除主键1ALTER TABLE stuinfo DROP PRIMARY KEY; 4.删除唯一1ALTER TABLE stuinfo DROP INDEX seat; 5.删除外键1ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"DDL语言————常见的数据类型","slug":"Database13","date":"2020-06-12T16:24:47.000Z","updated":"2020-06-12T17:03:26.000Z","comments":true,"path":"2020/06/13/Database13/","link":"","permalink":"https://duvin0512.github.io./2020/06/13/Database13/","excerpt":"整型 小数 字符型 日期型","text":"整型 小数 字符型 日期型 常见的数据类型数值型： 整型 小数： 定点数 浮点数 字符型： 较短的文本：char、varchar 较长的文本：text、blob（较长的二进制数据） 日期型 一、整型分类： tinyint smallint mediumint int/integer bigint 1 2 3 4 8 特点： 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值 如果不设置长度，会有默认的长度长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！ 1.如何设置无符号和有符号123456789101112131415161718DROP TABLE IF EXISTS tab_int;CREATE TABLE tab_int( t1 INT(7) ZEROFILL, t2 INT(7) ZEROFILL);DESC tab_int;INSERT INTO tab_int VALUES(-123456);INSERT INTO tab_int VALUES(-123456,-123456);INSERT INTO tab_int VALUES(2147483648,4294967296);INSERT INTO tab_int VALUES(123,123);SELECT * FROM tab_int; 二、小数分类： 1.浮点型float(M,D) double(M,D) 2.定点型dec(M,D) decimal(M,D) 特点： ①M：整数部位+小数部位 D：小数部位 如果超过范围，则插入临界值 ②M和D都可以省略 如果是decimal，则M默认为10，D默认为0 如果是float和double，则会根据插入的数值的精度来决定精度 ③定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用 123456789101112131415#测试M和DDROP TABLE tab_float;CREATE TABLE tab_float( f1 FLOAT, f2 DOUBLE, f3 DECIMAL);SELECT * FROM tab_float;DESC tab_float;INSERT INTO tab_float VALUES(123.4523,123.4523,123.4523);INSERT INTO tab_float VALUES(123.456,123.456,123.456);INSERT INTO tab_float VALUES(123.4,123.4,123.4);INSERT INTO tab_float VALUES(1523.4,1523.4,1523.4); 原则：所选择的类型越简单越好，能保存数值的类型越小越好 三、字符型 较短的文本： char varchar 其他： binary和varbinary用于保存较短的二进制 enum用于保存枚举 set用于保存集合 较长的文本： text blob(较大的二进制) 特点： | 写法 | M的意思 | 特点 | 空间的耗费 | 效率 || —- | ——- | —- | ———- | —- ||| char | char(M) | 最大的字符数，可以省略，默认为1 固定长度的字符 | 比较耗费 | 高 || varchar | varchar(M) | 最大的字符数，不可以省略 可变长度的字符 | 比较节省 | 低 | 123456789101112131415161718192021222324252627CREATE TABLE tab_char( c1 ENUM('a','b','c'));INSERT INTO tab_char VALUES('a');INSERT INTO tab_char VALUES('b');INSERT INTO tab_char VALUES('c');INSERT INTO tab_char VALUES('m');INSERT INTO tab_char VALUES('A');SELECT * FROM tab_set;CREATE TABLE tab_set( s1 SET('a','b','c','d'));INSERT INTO tab_set VALUES('a');INSERT INTO tab_set VALUES('A,B');INSERT INTO tab_set VALUES('a,c,d'); 四、日期型分类： date只保存日期 time 只保存时间 year只保存年 datetime保存日期+时间 timestamp保存日期+时间 特点： 名称 字节 范围 时区等的影响 datetime 8 1000——9999 不受 timestamp 4 1970-2038 受 12345678910111213141516CREATE TABLE tab_date( t1 DATETIME, t2 TIMESTAMP);INSERT INTO tab_date VALUES(NOW(),NOW());SELECT * FROM tab_date;SHOW VARIABLES LIKE 'time_zone';SET time_zone='+9:00';","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"DDL语言————库和表的管理","slug":"Database12","date":"2020-06-12T16:10:12.000Z","updated":"2020-06-12T17:03:36.000Z","comments":true,"path":"2020/06/13/Database12/","link":"","permalink":"https://duvin0512.github.io./2020/06/13/Database12/","excerpt":"库的管理 表的管理","text":"库的管理 表的管理 库和表的管理一、库的管理 创建、修改、删除 二、表的管理 创建、修改、删除 创建： create修改： alter删除： drop 一、库的管理1、库的创建语法： create database [if not exists]库名; 123#案例：创建库BooksCREATE DATABASE IF NOT EXISTS books ; 2、库的修改12# sql版本5.1.7中有，新版本不支持RENAME DATABASE books TO 新库名; 123#更改库的字符集ALTER DATABASE books CHARACTER SET gbk; 3、库的删除DROP DATABASE IF EXISTS books; 二、表的管理1.表的创建 ★语法： 123456789create table 表名( 列名 列的类型【(长度) 约束】, 列名 列的类型【(长度) 约束】, 列名 列的类型【(长度) 约束】, ... 列名 列的类型【(长度) 约束】) 123456789101112#案例：创建表BookCREATE TABLE book( id INT,#编号 bName VARCHAR(20),#图书名 price DOUBLE,#价格 authorId INT,#作者编号 publishDate DATETIME#出版日期); 1234567#案例：创建表authorCREATE TABLE IF NOT EXISTS author( id INT, au_name VARCHAR(20), nation VARCHAR(10)) 2.表的修改语法 1alter table 表名 add|drop|modify|change column 列名 【列类型 约束】; 修改列名 修改列的类型或约束 添加新列 删除列 修改表名 1234567891011121314151617#①修改列名ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;#②修改列的类型或约束ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;#③添加新列ALTER TABLE author ADD COLUMN annual DOUBLE; #④删除列ALTER TABLE book_author DROP COLUMN annual;#⑤修改表名ALTER TABLE author RENAME TO book_author; 3.表的删除123DROP TABLE IF EXISTS book_author;SHOW TABLES; 12345678#通用的写法：DROP DATABASE IF EXISTS 旧库名;CREATE DATABASE 新库名;DROP TABLE IF EXISTS 旧表名;CREATE TABLE 表名(); 4.表的复制1.仅仅复制表的结构CREATE TABLE copy LIKE author; 2.复制表的结构+数据12CREATE TABLE copy2SELECT * FROM author; 12345678910111213#只复制部分数据CREATE TABLE copy3SELECT id,au_nameFROM authorWHERE nation='中国';#仅仅复制某些字段CREATE TABLE copy4SELECT id,au_nameFROM authorWHERE 0;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"DML语言","slug":"Database11","date":"2020-06-11T16:28:51.000Z","updated":"2020-06-12T04:30:10.000Z","comments":true,"path":"2020/06/12/Database11/","link":"","permalink":"https://duvin0512.github.io./2020/06/12/Database11/","excerpt":"插入语句 修改语句 删除语句","text":"插入语句 修改语句 删除语句 DML语言数据操作语言： 插入：insert 修改：update 删除：delete 一、插入语句方式一：经典的插入语法： into 表名(列名,...) values(值1,...);```1234561. 插入的值的类型要与列的类型一致或兼容&#96;&#96;&#96;sqlINSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)VALUES(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2); 不可以为null的列必须插入值。可以为null的列如何插入值？ 123#方式一：INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)VALUES(13,'唐艺昕','女','1990-4-23','1898888888',NULL,2); 1234#方式二：INSERT INTO beauty(id,NAME,sex,phone)VALUES(15,'娜扎','女','1388888888'); 列的顺序是否可以调换 12INSERT INTO beauty(NAME,sex,id,phone)VALUES('蒋欣','女',16,'110'); 列数和值的个数必须一致 12INSERT INTO beauty(NAME,sex,id,phone)VALUES('关晓彤','女',17,'110'); 可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致 12INSERT INTO beautyVALUES(18,'张飞','男',NULL,'119',NULL,NULL); 方式二语法： 12insert into 表名set 列名=值,列名=值,... 12INSERT INTO beautySET id=19,NAME='刘涛',phone='999'; 两种方式大pk ★ 方式一支持插入多行,方式二不支持 1234INSERT INTO beautyVALUES(23,'唐艺昕1','女','1990-4-23','1898888888',NULL,2),(24,'唐艺昕2','女','1990-4-23','1898888888',NULL,2),(25,'唐艺昕3','女','1990-4-23','1898888888',NULL,2); 方式一支持子查询，方式二不支持 123456INSERT INTO beauty(id,NAME,phone)SELECT 26,'宋茜','11809866';INSERT INTO beauty(id,NAME,phone)SELECT id,boyname,'1234567'FROM boys WHERE id&lt;3; 二、修改语句 修改单表的记录★ 语法： 123update 表名set 列=新值,列=新值,...where 筛选条件; 修改多表的记录【补充】 语法： 12345#sql92语法：update 表1 别名,表2 别名set 列=值,...where 连接条件and 筛选条件; 123456#sql99语法：update 表1 别名inner|left|right join 表2 别名on 连接条件set 列=值,...where 筛选条件; 1.修改单表的记录1234#案例1：修改beauty表中姓唐的女神的电话为13899888899UPDATE beauty SET phone = '13899888899'WHERE NAME LIKE '唐%'; 123#案例2：修改boys表中id好为2的名称为张飞，魅力值 10UPDATE boys SET boyname='张飞',usercp=10WHERE id=2; 2.修改多表的记录123456#案例 1：修改张无忌的女朋友的手机号为114UPDATE boys boINNER JOIN beauty b ON bo.`id`=b.`boyfriend_id`SET b.`phone`='119',bo.`userCP`=1000WHERE bo.`boyName`='张无忌'; 12345678#案例2：修改没有男朋友的女神的男朋友编号都为2号UPDATE boys boRIGHT JOIN beauty b ON bo.`id`=b.`boyfriend_id`SET b.`boyfriend_id`=2WHERE bo.`id` IS NULL;SELECT * FROM boys; 三、删除语句方式一：delete 语法： 单表的删除【★】 1delete from 表名 where 筛选条件 多表的删除【补充】 12345#sql92语法：delete 表1的别名,表2的别名from 表1 别名,表2 别名where 连接条件and 筛选条件; 12345#sql99语法：delete 表1的别名,表2的别名from 表1 别名inner|left|right join 表2 别名 on 连接条件where 筛选条件; 方式二：truncate 语法： table 表名;```12345678910#### 方式一：delete1. 单表的删除&#96;&#96;&#96;sql#案例：删除手机号以9结尾的女神信息DELETE FROM beauty WHERE phone LIKE &#39;%9&#39;;SELECT * FROM beauty; 多表的删除 123456#案例：删除张无忌的女朋友的信息DELETE bFROM beauty bINNER JOIN boys bo ON b.`boyfriend_id` = bo.`id`WHERE bo.`boyName`='张无忌'; 12345#案例：删除黄晓明的信息以及他女朋友的信息DELETE b,boFROM beauty bINNER JOIN boys bo ON b.`boyfriend_id`=bo.`id`WHERE bo.`boyName`='黄晓明'; 方式二：truncate语句12#案例：将魅力值&gt;100的男神信息删除TRUNCATE TABLE boys ; delete pk truncate【面试题★】 delete 可以加where 条件，truncate不能加 truncate删除，效率高一丢丢 假如要删除的表中有自增长列， 如果用delete删除后，再插入数据，自增长列的值从断点开始， 而truncate删除后，再插入数据，自增长列的值从1开始。4. truncate删除没有返回值，delete删除有返回值5. truncate删除不能回滚，delete删除可以回滚. 123456SELECT * FROM boys;DELETE FROM boys;TRUNCATE TABLE boys;INSERT INTO boys (boyname,usercp)VALUES('张飞',100),('刘备',100),('关云长',100);","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"DQL语言————联合查询","slug":"Database10","date":"2020-06-11T16:16:35.000Z","updated":"2020-06-11T16:19:34.000Z","comments":true,"path":"2020/06/12/Database10/","link":"","permalink":"https://duvin0512.github.io./2020/06/12/Database10/","excerpt":"语法 应用场景 特点 案例","text":"语法 应用场景 特点 案例 联合查询union 联合 合并：将多条查询语句的结果合并成一个结果 语法12345查询语句1union查询语句2union... 应用场景要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时 特点：★ 要求多条查询语句的查询列数是一致的！ 要求多条查询语句的查询的每一列的类型和顺序最好一致 union关键字默认去重，如果使用union all 可以包含重复项 案例1234567#引入的案例：查询部门编号&gt;90或邮箱包含a的员工信息SELECT * FROM employees WHERE email LIKE '%a%' OR department_id&gt;90;;SELECT * FROM employees WHERE email LIKE '%a%'UNIONSELECT * FROM employees WHERE department_id&gt;90; 12345#案例：查询中国用户中男性的信息以及外国用户中年男性的用户信息SELECT id,cname FROM t_ca WHERE csex='男'UNION ALLSELECT t_id,tname FROM t_ua WHERE tGender='male';","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"DQL语言————分页查询","slug":"Database09","date":"2020-06-11T15:21:34.000Z","updated":"2020-06-11T16:16:42.000Z","comments":true,"path":"2020/06/11/Database09/","link":"","permalink":"https://duvin0512.github.io./2020/06/11/Database09/","excerpt":"应用场景 语法 特点 案例","text":"应用场景 语法 特点 案例 分页查询 ★应用场景当要显示的数据，一页显示不全，需要分页提交sql请求 语法123456789101112select 查询列表from 表【join type join 表2on 连接条件where 筛选条件group by 分组字段having 分组后的筛选order by 排序的字段】limit 【offset,】size;#offset要显示条目的起始索引（起始索引从0开始）#size 要显示的条目个数 特点 limit语句放在查询语句的最后 公式 1234567891011要显示的页数 page，每页的条目数sizeselect 查询列表from 表limit (page-1)*size,size;size=10page 1 02 103 20 案例12345#案例1：查询前五条员工信息SELECT * FROM employees LIMIT 0,5;SELECT * FROM employees LIMIT 5; 12#案例2：查询第11条——第25条SELECT * FROM employees LIMIT 10,15; 12345678#案例3：有奖金的员工信息，并且工资较高的前10名显示出来SELECT *FROM employeesWHERE commission_pct IS NOT NULLORDER BY salary DESCLIMIT 10 ;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"DQL语言———子查询","slug":"Database08","date":"2020-06-10T14:53:26.000Z","updated":"2020-06-11T15:23:00.000Z","comments":true,"path":"2020/06/10/Database08/","link":"","permalink":"https://duvin0512.github.io./2020/06/10/Database08/","excerpt":"select后面 from后面 where或having后面★ exists后面","text":"select后面 from后面 where或having后面★ exists后面 子查询含义： 出现在其他语句中的select语句，称为子查询或内查询 外部的查询语句，称为主查询或外查询 分类： 按子查询出现的位置： select后面： 仅仅支持标量子查询 from后面： 支持表子查询 where或having后面：★ 标量子查询（单行） √ 列子查询 （多行） √ 行子查询 exists后面（相关子查询） 表子查询 按结果集的行列数不同： 标量子查询（结果集只有一行一列） 列子查询（结果集只有一列多行） 行子查询（结果集有一行多列） 表子查询（结果集一般为多行多列） 一、where或having后面 标量子查询（单行子查询） 列子查询（多行子查询） 行子查询（多列多行） 特点： 子查询放在小括号内 子查询一般放在条件的右侧 标量子查询，一般搭配着单行操作符使用 &gt; &lt; &gt;= &lt;= = &lt;&gt; 列子查询，一般搭配着多行操作符使用in、any/some、all 子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果 1.标量子查询★123456789101112131415161718#案例1：谁的工资比 Abel 高?#①查询Abel的工资SELECT salaryFROM employeesWHERE last_name = 'Abel'#②查询员工的信息，满足 salary&gt;①结果SELECT *FROM employeesWHERE salary&gt;( SELECT salary FROM employees WHERE last_name = 'Abel'); 1234567891011121314151617181920212223242526#案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资#①查询141号员工的job_idSELECT job_idFROM employeesWHERE employee_id = 141#②查询143号员工的salarySELECT salaryFROM employeesWHERE employee_id = 143#③查询员工的姓名，job_id 和工资，要求job_id=①并且salary&gt;②SELECT last_name,job_id,salaryFROM employeesWHERE job_id = ( SELECT job_id FROM employees WHERE employee_id = 141) AND salary&gt;( SELECT salary FROM employees WHERE employee_id = 143); 12345678910111213#案例3：返回公司工资最少的员工的last_name,job_id和salary#①查询公司的 最低工资SELECT MIN(salary)FROM employees#②查询last_name,job_id和salary，要求salary=①SELECT last_name,job_id,salaryFROM employeesWHERE salary=( SELECT MIN(salary) FROM employees); 123456789101112131415161718192021222324#案例4：查询最低工资大于50号部门最低工资的部门id和其最低工资#①查询50号部门的最低工资SELECT MIN(salary)FROM employeesWHERE department_id = 50#②查询每个部门的最低工资SELECT MIN(salary),department_idFROM employeesGROUP BY department_id#③ 在②基础上筛选，满足min(salary)&gt;①SELECT MIN(salary),department_idFROM employeesGROUP BY department_idHAVING MIN(salary)&gt;( SELECT MIN(salary) FROM employees WHERE department_id = 50); 123456789101112#非法使用标量子查询SELECT MIN(salary),department_idFROM employeesGROUP BY department_idHAVING MIN(salary)&gt;( SELECT salary FROM employees WHERE department_id = 250); 2.列子查询（多行子查询）★12345678910111213141516171819#案例1：返回location_id是1400或1700的部门中的所有员工姓名#①查询location_id是1400或1700的部门编号SELECT DISTINCT department_idFROM departmentsWHERE location_id IN(1400,1700)#②查询员工姓名，要求部门号是①列表中的某一个SELECT last_nameFROM employeesWHERE department_id &lt;&gt;ALL( SELECT DISTINCT department_id FROM departments WHERE location_id IN(1400,1700)); 123456789101112131415161718192021222324252627#案例2：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary#①查询job_id为‘IT_PROG’部门任一工资SELECT DISTINCT salaryFROM employeesWHERE job_id = 'IT_PROG'#②查询员工号、姓名、job_id 以及salary，salary&lt;(①)的任意一个SELECT last_name,employee_id,job_id,salaryFROM employeesWHERE salary&lt;ANY( SELECT DISTINCT salary FROM employees WHERE job_id = 'IT_PROG') AND job_id&lt;&gt;'IT_PROG';#或SELECT last_name,employee_id,job_id,salaryFROM employeesWHERE salary&lt;( SELECT MAX(salary) FROM employees WHERE job_id = 'IT_PROG') AND job_id&lt;&gt;'IT_PROG'; 123456789101112131415161718192021#案例3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工 的员工号、姓名、job_id 以及salarySELECT last_name,employee_id,job_id,salaryFROM employeesWHERE salary&lt;ALL( SELECT DISTINCT salary FROM employees WHERE job_id = 'IT_PROG') AND job_id&lt;&gt;'IT_PROG';#或SELECT last_name,employee_id,job_id,salaryFROM employeesWHERE salary&lt;( SELECT MIN( salary) FROM employees WHERE job_id = 'IT_PROG') AND job_id&lt;&gt;'IT_PROG'; 3、行子查询（结果集一行多列或多行多列）123456789101112131415161718192021222324252627282930313233#案例：查询员工编号最小并且工资最高的员工信息SELECT *FROM employeesWHERE (employee_id,salary)=( SELECT MIN(employee_id),MAX(salary) FROM employees);#①查询最小的员工编号SELECT MIN(employee_id)FROM employees#②查询最高工资SELECT MAX(salary)FROM employees#③查询员工信息SELECT *FROM employeesWHERE employee_id=( SELECT MIN(employee_id) FROM employees)AND salary=( SELECT MAX(salary) FROM employees); 二、select后面仅仅支持标量子查询 123456789101112131415161718192021#案例：查询每个部门的员工个数SELECT d.*,( SELECT COUNT(*) FROM employees e WHERE e.department_id = d.`department_id` ) 个数 FROM departments d; #案例2：查询员工号=102的部门名 SELECT ( SELECT department_name,e.department_id FROM departments d INNER JOIN employees e ON d.department_id=e.department_id WHERE e.employee_id=102 ) 部门名; 三、from后面将子查询结果充当一张表，要求必须起别名 1234567891011121314151617181920#案例：查询每个部门的平均工资的工资等级#①查询每个部门的平均工资SELECT AVG(salary),department_idFROM employeesGROUP BY department_idSELECT * FROM job_grades;#②连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_salSELECT ag_dep.*,g.`grade_level`FROM ( SELECT AVG(salary) ag,department_id FROM employees GROUP BY department_id) ag_depINNER JOIN job_grades gON ag_dep.ag BETWEEN lowest_sal AND highest_sal; 四、exists后面（相关子查询）语法： exists(完整的查询语句) 结果：1或0 1SELECT EXISTS(SELECT employee_id FROM employees WHERE salary=300000); 12345678910111213141516171819202122#案例1：查询有员工的部门名#inSELECT department_nameFROM departments dWHERE d.`department_id` IN( SELECT department_id FROM employees)#existsSELECT department_nameFROM departments dWHERE EXISTS( SELECT * FROM employees e WHERE d.`department_id`=e.`department_id`); 1234567891011121314151617181920#案例2：查询没有女朋友的男神信息#inSELECT bo.*FROM boys boWHERE bo.id NOT IN( SELECT boyfriend_id FROM beauty)#existsSELECT bo.*FROM boys boWHERE NOT EXISTS( SELECT boyfriend_id FROM beauty b WHERE bo.`id`=b.`boyfriend_id`);","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"DQL语言———连接查询","slug":"Database07","date":"2020-06-10T07:22:31.000Z","updated":"2020-06-10T14:22:06.000Z","comments":true,"path":"2020/06/10/Database07/","link":"","permalink":"https://duvin0512.github.io./2020/06/10/Database07/","excerpt":"含义 分类 sql92标准 sql99标准","text":"含义 分类 sql92标准 sql99标准 连接查询1. 含义又称多表查询，当查询的字段来自于多个表时，就会用到连接查询 笛卡尔乘积现象：表1 有m行，表2有n行，结果=m*n行 发生原因：没有有效的连接条件如何避免：添加有效的连接条件 2. 分类 按年代分类： sql92标准:仅仅支持内连接 sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接 按功能分类： 内连接： 等值连接 非等值连接 自连接 外连接： 左外连接 右外连接 全外连接 交叉连接 一、sql92标准1. 等值连接 多表等值连接的结果为多表的交集部分 n表连接，至少需要n-1个连接条件 多表的顺序没有要求 一般需要为表起别名 可以搭配前面介绍的所有子句使用，比如排序、分组、筛选 1234#案例1：查询女神名和对应的男神名SELECT NAME,boyNameFROM boys,beautyWHERE beauty.boyfriend_id= boys.id; 12345#案例2：查询员工名和对应的部门名SELECT last_name,department_nameFROM employees,departmentsWHERE employees.`department_id`=departments.`department_id`; 2. 为表起别名 提高语句的简洁度 区分多个重名的字段 注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定 12345#查询员工名、工种号、工种名SELECT e.last_name,e.job_id,j.job_titleFROM employees e,jobs jWHERE e.`job_id`=j.`job_id`; 3. 两个表的顺序是否可以调换12345#查询员工名、工种号、工种名SELECT e.last_name,e.job_id,j.job_titleFROM jobs j,employees eWHERE e.`job_id`=j.`job_id`; 4、可以加筛选1234567#案例：查询有奖金的员工名、部门名SELECT last_name,department_name,commission_pctFROM employees e,departments dWHERE e.`department_id`=d.`department_id`AND e.`commission_pct` IS NOT NULL; 123456#案例2：查询城市名中第二个字符为o的部门名和城市名SELECT department_name,cityFROM departments d,locations lWHERE d.`location_id` = l.`location_id`AND city LIKE '_o%'; 5、可以加分组123456#案例1：查询每个城市的部门个数SELECT COUNT(*) 个数,cityFROM departments d,locations lWHERE d.`location_id`=l.`location_id`GROUP BY city; 123456#案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资SELECT department_name,d.`manager_id`,MIN(salary)FROM departments d,employees eWHERE d.`department_id`=e.`department_id`AND commission_pct IS NOT NULLGROUP BY department_name,d.`manager_id`; 6、可以加排序1234567#案例：查询每个工种的工种名和员工的个数，并且按员工个数降序SELECT job_title,COUNT(*)FROM employees e,jobs jWHERE e.`job_id`=j.`job_id`GROUP BY job_titleORDER BY COUNT(*) DESC; 7、可以实现三表连接123456789#案例：查询员工名、部门名和所在的城市SELECT last_name,department_name,cityFROM employees e,departments d,locations lWHERE e.`department_id`=d.`department_id`AND d.`location_id`=l.`location_id`AND city LIKE 's%'ORDER BY department_name DESC; 2、非等值连接1234567#案例1：查询员工的工资和工资级别SELECT salary,grade_levelFROM employees e,job_grades gWHERE salary BETWEEN g.`lowest_sal` AND g.`highest_sal`AND g.`grade_level`='A'; 123456789101112131415161718192021222324select salary,employee_id from employees;select * from job_grades;CREATE TABLE job_grades(grade_level VARCHAR(3), lowest_sal int, highest_sal int);INSERT INTO job_gradesVALUES ('A', 1000, 2999);INSERT INTO job_gradesVALUES ('B', 3000, 5999);INSERT INTO job_gradesVALUES('C', 6000, 9999);INSERT INTO job_gradesVALUES('D', 10000, 14999);INSERT INTO job_gradesVALUES('E', 15000, 24999);INSERT INTO job_gradesVALUES('F', 25000, 40000); 3、自连接12345#案例：查询 员工名和上级的名称SELECT e.employee_id,e.last_name,m.employee_id,m.last_nameFROM employees e,employees mWHERE e.`manager_id`=m.`employee_id`; 二、sql99语法语法 12345678select 查询列表from 表1 别名 【连接类型】join 表2 别名on 连接条件【where 筛选条件】【group by 分组】【having 筛选条件】【order by 排序列表】 分类 内连接（★）：inner 外连接 左外(★):left 【outer】 右外(★)：right 【outer】 全外：full【outer】 交叉连接：cross 一、内连接语法： 1234select 查询列表from 表1 别名inner join 表2 别名on 连接条件; 分类： 等值 非等值 自连接 特点： 添加排序、分组、筛选 inner可以省略 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读 inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集 一）等值连接123456#案例1.查询员工名、部门名SELECT last_name,department_nameFROM departments dJOIN employees eON e.`department_id` = d.`department_id`; 123456#案例2.查询名字中包含e的员工名和工种名（添加筛选）SELECT last_name,job_titleFROM employees eINNER JOIN jobs jON e.`job_id`= j.`job_id`WHERE e.`last_name` LIKE '%e%'; 12345678910#案例3. 查询部门个数&gt;3的城市名和部门个数，（添加分组+筛选）#①查询每个城市的部门个数#②在①结果上筛选满足条件的SELECT city,COUNT(*) 部门个数FROM departments dINNER JOIN locations lON d.`location_id`=l.`location_id`GROUP BY cityHAVING COUNT(*)&gt;3; 123456789101112131415161718#案例4.查询哪个部门的员工个数&gt;3的部门名和员工个数，并按个数降序（添加排序）#①查询每个部门的员工个数SELECT COUNT(*),department_nameFROM employees eINNER JOIN departments dON e.`department_id`=d.`department_id`GROUP BY department_name#② 在①结果上筛选员工个数&gt;3的记录，并排序SELECT COUNT(*) 个数,department_nameFROM employees eINNER JOIN departments dON e.`department_id`=d.`department_id`GROUP BY department_nameHAVING COUNT(*)&gt;3ORDER BY COUNT(*) DESC; 12345678#案例5.查询员工名、部门名、工种名，并按部门名降序（添加三表连接）SELECT last_name,department_name,job_titleFROM employees eINNER JOIN departments d ON e.`department_id`=d.`department_id`INNER JOIN jobs j ON e.`job_id` = j.`job_id`ORDER BY department_name DESC; 二）非等值连接123456#查询员工的工资级别SELECT salary,grade_levelFROM employees eJOIN job_grades gON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`; 12345678#查询工资级别的个数&gt;20的个数，并且按工资级别降序SELECT COUNT(*),grade_levelFROM employees eJOIN job_grades gON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`GROUP BY grade_levelHAVING COUNT(*)&gt;20ORDER BY grade_level DESC; 三）自连接12345#查询员工的名字、上级的名字SELECT e.last_name,m.last_nameFROM employees eJOIN employees mON e.`manager_id`= m.`employee_id`; 123456#查询姓名中包含字符k的员工的名字、上级的名字SELECT e.last_name,m.last_nameFROM employees eJOIN employees mON e.`manager_id`= m.`employee_id`WHERE e.`last_name` LIKE '%k%'; 二、外连接应用场景：用于查询一个表中有，另一个表没有的记录 特点： 外连接的查询结果为主表中的所有记录 如果从表中有和它匹配的，则显示匹配的值 如果从表中没有和它匹配的，则显示null 外连接查询结果=内连接结果+主表中有而从表没有的记录 左外连接，left join左边的是主表 右外连接，right join右边的是主表 左外和右外交换两个表的顺序，可以实现同样的效果 全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的 1234567891011#引入：查询男朋友 不在男神表的的女神名SELECT * FROM beauty;SELECT * FROM boys;#左外连接SELECT b.*,bo.*FROM boys boLEFT OUTER JOIN beauty bON b.`boyfriend_id` = bo.`id`WHERE b.`id` IS NULL; 1234567891011121314151617181920212223#案例1：查询哪个部门没有员工#左外SELECT d.*,e.employee_idFROM departments dLEFT OUTER JOIN employees eON d.`department_id` = e.`department_id`WHERE e.`employee_id` IS NULL;#右外SELECT d.*,e.employee_idFROM employees eRIGHT OUTER JOIN departments dON d.`department_id` = e.`department_id`WHERE e.`employee_id` IS NULL;#全外USE girls;SELECT b.*,bo.*FROM beauty bFULL OUTER JOIN boys boON b.`boyfriend_id` = bo.id; 交叉连接123SELECT b.*,bo.*FROM beauty bCROSS JOIN boys bo; sql92和 sql99pk功能：sql99支持的较多 可读性：sql99实现连接条件和筛选条件的分离，可读性较高","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"DQL语言————分组查询","slug":"Database06","date":"2020-06-09T14:37:14.000Z","updated":"2020-06-10T10:54:44.000Z","comments":true,"path":"2020/06/09/Database06/","link":"","permalink":"https://duvin0512.github.io./2020/06/09/Database06/","excerpt":"语法 特点 案例","text":"语法 特点 案例 分组查询1. 语法12345select 查询列表from 表【where 筛选条件】group by 分组的字段【order by 排序的字段】; 2. 特点 和分组函数一同查询的字段必须是group by后出现的字段 筛选分为两类：分组前筛选和分组后筛选 针对的表 位置 连接的关键字 分组前筛选 原始表 group by前 where 分组后筛选 group by后的结果集 group by后 having 问题1：分组函数做筛选能不能放在where后面答：不能 问题2：where——group by——having 一般来讲，能用分组前筛选的，尽量使用分组前筛选，提高效率 分组可以按单个字段也可以按多个字段 可以搭配着排序使用 3， 案例0. 引入：查询每个部门的员工个数1SELECT COUNT(*) FROM employees WHERE department_id=90; 1. 简单的分组1234#案例1：查询每个工种的员工平均工资SELECT AVG(salary),job_idFROM employeesGROUP BY job_id; 12345#案例2：查询每个位置的部门个数SELECT COUNT(*),location_idFROM departmentsGROUP BY location_id; 2. 可以实现分组前的筛选123456#案例1：查询邮箱中包含a字符的 每个部门的最高工资SELECT MAX(salary),department_idFROM employeesWHERE email LIKE '%a%'GROUP BY department_id; 123456#案例2：查询有奖金的每个领导手下员工的平均工资SELECT AVG(salary),employee_idFROM employeesWHERE commission_pct IS NOT NULLGROUP BY manager_id; 3. 分组后筛选123456789101112131415#案例：查询哪个部门的员工个数&gt;5#①查询每个部门的员工个数SELECT COUNT(*),department_idFROM employeesGROUP BY department_id;#② 筛选刚才①结果SELECT COUNT(*),department_idFROM employeesGROUP BY department_idHAVING COUNT(*)&gt;5; 1234567#案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资SELECT job_id,MAX(salary)FROM employeesWHERE commission_pct IS NOT NULLGROUP BY job_idHAVING MAX(salary)&gt;12000; 12345678#案例3：领导编号&gt;102的每个领导手下的最低工资大于5000的领导编号和最低工资manager_id&gt;102SELECT manager_id,MIN(salary)FROM employeesGROUP BY manager_idHAVING MIN(salary)&gt;5000; 4. 添加排序12345678#案例：每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序SELECT job_id,MAX(salary) mFROM employeesWHERE commission_pct IS NOT NULLGROUP BY job_idHAVING m&gt;6000ORDER BY m ; 5. 按多个字段分组123456#案例：查询每个工种每个部门的最低工资,并按最低工资降序SELECT MIN(salary),job_id,department_idFROM employeesGROUP BY department_id,job_idORDER BY MIN(salary) DESC;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"DQL语言————常用函数","slug":"Database05","date":"2020-06-09T12:18:21.000Z","updated":"2020-06-10T13:12:02.000Z","comments":true,"path":"2020/06/09/Database05/","link":"","permalink":"https://duvin0512.github.io./2020/06/09/Database05/","excerpt":"好处 调用 特点 分类","text":"好处 调用 特点 分类 常见函数概念：类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名 好处 隐藏了实现细节 提高代码的重用性 调用select 函数名(实参列表) 【from 表】; 特点 叫什么（函数名） 干什么（函数功能） 分类1. 单行函数如 concat、length、ifnull等 一、字符函数 length 获取参数值的字节个数 1234SELECT LENGTH('john');SELECT LENGTH('张三丰hahaha');SHOW VARIABLES LIKE '%char%' concat 拼接字符串 1SELECT CONCAT(last_name,'_',first_name) 姓名 FROM employees; upper、lower 1234SELECT UPPER('john');SELECT LOWER('joHn');#示例：将姓变大写，名变小写，然后拼接SELECT CONCAT(UPPER(last_name),LOWER(first_name)) 姓名 FROM employees; 4.bsubstr、substring 注意：索引从1开始 12345#截取从指定索引处后面所有字符SELECT SUBSTR('李莫愁爱上了陆展元',7) out_put;#截取从指定索引处指定字符长度的字符SELECT SUBSTR('李莫愁爱上了陆展元',1,3) out_put; 1234#案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),'_',LOWER(SUBSTR(last_name,2))) out_putFROM employees; instr 返回子串第一次出现的索引，如果找不到返回0 1ELECT INSTR('杨不殷六侠悔爱上了殷六侠','殷八侠') AS out_put; trim 123SELECT LENGTH(TRIM(' 张翠山 ')) AS out_put;SELECT TRIM('aa' FROM 'aaaaaaaaa张aaaaaaaaaaaa翠山aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') AS out_put; lpad 用指定的字符实现左填充指定长度 1SELECT LPAD('殷素素',2,'*') AS out_put; rpad 用指定的字符实现右填充指定长度 1SELECT RPAD('殷素素',12,'ab') AS out_put; replace 替换 1SELECT REPLACE('周芷若周芷若周芷若周芷若张无忌爱上了周芷若','周芷若','赵敏') AS out_put; 二、数学函数 round 四舍五入 12SELECT ROUND(-1.55);SELECT ROUND(1.567,2); ceil 向上取整,返回&gt;=该参数的最小整数 1SELECT CEIL(-1.02); floor 向下取整，返回&lt;=该参数的最大整数 1SELECT FLOOR(-9.99); truncate 截断 1SELECT TRUNCATE(1.69999,1); mod取余 1234567/*mod(a,b) ： a-a/b*bmod(-10,-3):-10- (-10)/(-3)*（-3）=-1*/SELECT MOD(10,-3);SELECT 10%3; rand:获取随机数，返回0-1之间的小数 三、日期函数 now 返回当前系统日期+时间 1SELECT NOW(); curdate 返回当前系统日期，不包含时间 1SELECT CURDATE(); curtime 返回当前时间，不包含日期 1SELECT CURTIME(); 12345678#可以获取指定的部分，年、月、日、小时、分钟、秒SELECT YEAR(NOW()) 年;SELECT YEAR('1998-1-1') 年;SELECT YEAR(hiredate) 年 FROM employees;SELECT MONTH(NOW()) 月;SELECT MONTHNAME(NOW()) 月; str_to_date 将字符通过指定的格式转换成日期 1SELECT STR_TO_DATE('1998-3-2','%Y-%c-%d') AS out_put; 1234#查询入职日期为1992-4-3的员工信息SELECT * FROM employees WHERE hiredate = '1992-4-3';SELECT * FROM employees WHERE hiredate = STR_TO_DATE('4-3 1992','%c-%d %Y'); date_format 将日期转换成字符 1SELECT DATE_FORMAT(NOW(),'%y年%m月%d日') AS out_put; 1234#查询有奖金的员工名和入职日期(xx月/xx日 xx年)SELECT last_name,DATE_FORMAT(hiredate,'%m月/%d日 %y年') 入职日期FROM employeesWHERE commission_pct IS NOT NULL; 序号 格式符 功能 1 %Y 四位的年份 2 %y 2位的年份 3 %m 月份(01,02,…11,12) 4 %c 月份(1,2…11,12) 5 %d 日(01,02…) 6 %H 小时(24小时制) 7 %h 小时(12小时制) 8 %i 分钟(00,01,…59 ) 9 %s 秒( 00,01,…59 ) 其他 datediff:返回两个日期相差的天数monthname:以英文形式返回月year:返回年month：返回月day:返回日hour:小时minute:分钟second：秒 四、其他函数version 当前数据库服务器的版本 database 当前打开的数据库 user当前用户 password(‘字符’)：返回该字符的密码形式 md5(‘字符’):返回该字符的md5加密形式 五、流程控制函数 if函数： if else 的效果 1234SELECT IF(10&lt;5,'大','小');SELECT last_name,commission_pct,IF(commission_pct IS NULL,'没奖金，呵呵','有奖金，嘻嘻') 备注FROM employees; case函数的使用一： switch case 的效果 java中 12345switch(变量或表达式)&#123; case 常量1：语句1;break; ... default:语句n;break;&#125; mysql中 123456case 要判断的字段或表达式when 常量1 then 要显示的值1或语句1;when 常量2 then 要显示的值2或语句2;...else 要显示的值n或语句n;end 123456789101112131415161718/*案例：查询员工的工资，要求部门号=30，显示的工资为1.1倍部门号=40，显示的工资为1.2倍部门号=50，显示的工资为1.3倍其他部门，显示的工资为原工资*/SELECT salary 原始工资,department_id,CASE department_idWHEN 30 THEN salary*1.1WHEN 40 THEN salary*1.2WHEN 50 THEN salary*1.3ELSE salaryEND AS 新工资FROM employees; case 函数的使用二：类似于 多重if java中： 123456789if(条件1)&#123; 语句1；&#125;else if(条件2)&#123; 语句2；&#125;...else&#123; 语句n;&#125; mysql中： 123456case when 条件1 then 要显示的值1或语句1when 条件2 then 要显示的值2或语句2...else 要显示的值n或语句nend 123456789101112131415/*案例：查询员工的工资的情况如果工资&gt;20000,显示A级别如果工资&gt;15000,显示B级别如果工资&gt;10000，显示C级别否则，显示D级别*/SELECT salary,CASEWHEN salary&gt;20000 THEN 'A'WHEN salary&gt;15000 THEN 'B'WHEN salary&gt;10000 THEN 'C'ELSE 'D'END AS 工资级别FROM employees; 2. 分组函数功能：做统计使用，又称为统计函数、聚合函数、组函数 分类： sum 求和、avg 平均值、max 最大值 、min 最小值 、count 计算个数 特点： sum、avg一般用于处理数值型max、min、count可以处理任何类型 以上分组函数都忽略null值 可以和distinct搭配实现去重的运算 count函数的单独介绍一般使用count(*)用作统计行数 和分组函数一同查询的字段要求是group by后的字段 1.简单的使用123456789101112SELECT SUM(salary) FROM employees;SELECT AVG(salary) FROM employees;SELECT MIN(salary) FROM employees;SELECT MAX(salary) FROM employees;SELECT COUNT(salary) FROM employees;SELECT SUM(salary) 和,AVG(salary) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数FROM employees;SELECT SUM(salary) 和,ROUND(AVG(salary),2) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数FROM employees; 2.参数支持哪些类型123456789SELECT SUM(last_name) ,AVG(last_name) FROM employees;SELECT SUM(hiredate) ,AVG(hiredate) FROM employees;SELECT MAX(last_name),MIN(last_name) FROM employees;SELECT MAX(hiredate),MIN(hiredate) FROM employees;SELECT COUNT(commission_pct) FROM employees;SELECT COUNT(last_name) FROM employees; 3.是否忽略null123456SELECT SUM(commission_pct) ,AVG(commission_pct),SUM(commission_pct)/35,SUM(commission_pct)/107 FROM employees;SELECT MAX(commission_pct) ,MIN(commission_pct) FROM employees;SELECT COUNT(commission_pct) FROM employees;SELECT commission_pct FROM employees; 4.和distinct搭配123SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;SELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees; 5.count函数的详细介绍123456SELECT COUNT(salary) FROM employees;SELECT COUNT(*) FROM employees;SELECT COUNT(1) FROM employees; 效率： MYISAM存储引擎下，COUNT()的效率高INNODB存储引擎下，COUNT()和COUNT(1)的效率差不多，比COUNT(字段)要高一些 6.和分组函数一同查询的字段有限制1SELECT AVG(salary),employee_id FROM employees;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"DQL语言————排序查询","slug":"Database04","date":"2020-06-09T12:14:47.000Z","updated":"2020-06-09T12:19:38.000Z","comments":true,"path":"2020/06/09/Database04/","link":"","permalink":"https://duvin0512.github.io./2020/06/09/Database04/","excerpt":"语法 特点 示例","text":"语法 特点 示例 排序查询1. 语法1234select 查询列表from 表名【where 筛选条件】order by 排序的字段或表达式; 2. 特点 asc代表的是升序，可以省略desc代表的是降序 order by子句可以支持 单个字段、别名、表达式、函数、多个字段 order by子句在查询语句的最后面，除了limit子句 3.案例 按单个字段排序 1SELECT * FROM employees ORDER BY salary DESC; 添加筛选条件再排序 12345#案例：查询部门编号&gt;=90的员工信息，并按员工编号降序SELECT *FROM employeesWHERE department_id&gt;=90ORDER BY employee_id DESC; 按表达式排序 1234#案例：查询员工信息 按年薪降序SELECT *,salary*12*(1+IFNULL(commission_pct,0))FROM employeesORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC; 按别名排序 1234#案例：查询员工信息 按年薪升序SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪FROM employeesORDER BY 年薪 ASC; 按函数排序 1234#案例：查询员工名，并且按名字的长度降序SELECT LENGTH(last_name),last_nameFROM employeesORDER BY LENGTH(last_name) DESC; 按多个字段排序 1234#案例：查询员工信息，要求先按工资降序，再按employee_id升序SELECT *FROM employeesORDER BY salary DESC,employee_id ASC;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"DQL语言————条件查询","slug":"Database03","date":"2020-06-09T12:11:51.000Z","updated":"2020-06-09T12:16:52.000Z","comments":true,"path":"2020/06/09/Database03/","link":"","permalink":"https://duvin0512.github.io./2020/06/09/Database03/","excerpt":"语法 特点 示例","text":"语法 特点 示例 条件查询1. 语法123456select 查询列表from 表名where 筛选条件; 2. 分类 按条件表达式筛选 简单条件运算符：&gt; &lt; = != &lt;&gt; &gt;= &lt;= 按逻辑表达式筛选 逻辑运算符： 作用：用于连接条件表达式 &amp;&amp; || ! and or not &amp;&amp;和and： 两个条件都为true，结果为true，反之为false ||或or： 只要有一个条件为true，结果为true，反之为false !或not： 如果连接的条件本身为false，结果为true，反之为false 模糊查询 like between and in is null 3. 案例一、按条件表达式筛选1234567#案例1：查询工资&gt;12000的员工信息SELECT *FROM employeesWHERE salary&gt;12000; 12345678#案例2：查询部门编号不等于90号的员工名和部门编号SELECT last_name, department_idFROM employeesWHERE department_id&lt;&gt;90; 二、按逻辑表达式筛选123456789#案例1：查询工资z在10000到20000之间的员工名、工资以及奖金SELECT last_name, salary, commission_pctFROM employeesWHERE salary&gt;=10000 AND salary&lt;=20000; 1234567#案例2：查询部门编号不是在90到110之间，或者工资高于15000的员工信息SELECT *FROM employeesWHERE NOT(department_id&gt;=90 AND department_id&lt;=110) OR salary&gt;15000; 三、模糊查询1. like特点： 一般和通配符搭配使用 通配符： % 任意多个字符,包含0个字符 _ 任意单个字符 1234567#案例1：查询员工名中包含字符a的员工信息select *from employeeswhere last_name like '%a%';#abc 12345678#案例2：查询员工名中第三个字符为e，第五个字符为a的员工名和工资select last_name, salaryFROM employeesWHERE last_name LIKE '__n_l%'; 1234567#案例3：查询员工名中第二个字符为_的员工名SELECT last_nameFROM employeesWHERE last_name LIKE '_$_%' ESCAPE '$'; 2. between and 使用between and 可以提高语句的简洁度 包含临界值 两个临界值不要调换顺序 1234567891011121314#案例1：查询员工编号在100到120之间的员工信息SELECT *FROM employeesWHERE employee_id &gt;= 120 AND employee_id&lt;=100;#----------------------SELECT *FROM employeesWHERE employee_id BETWEEN 120 AND 100; 3. in含义：判断某字段的值是否属于in列表中的某一项 特点： 使用in提高语句简洁度 in列表的值类型必须一致或兼容 in列表中不支持通配符 123456789101112131415161718#案例：查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号SELECT last_name, job_idFROM employeesWHERE job_id = 'IT_PROT' OR job_id = 'AD_VP' OR JOB_ID ='AD_PRES';#------------------SELECT last_name, job_idFROM employeesWHERE job_id IN( 'IT_PROT' ,'AD_VP','AD_PRES'); 4. is null=或&lt;&gt;不能用于判断null值 is null或is not null 可以判断null值 12345678#案例1：查询没有奖金的员工名和奖金率SELECT last_name, commission_pctFROM employeesWHERE commission_pct IS NULL; 123456789101112131415161718#案例2：查询有奖金的员工名和奖金率SELECT last_name, commission_pctFROM employeesWHERE commission_pct IS NOT NULL;#----------以下为×SELECT last_name, commission_pctFROM employeesWHERE salary IS 12000; 5. 安全等于 &lt;=&gt;12345678#案例1：查询没有奖金的员工名和奖金率SELECT last_name, commission_pctFROM employeesWHERE commission_pct &lt;=&gt;NULL; 123456789#案例2：查询工资为12000的员工信息SELECT last_name, salaryFROM employeesWHERE salary &lt;=&gt; 12000; 6. is null pk &lt;=&gt;IS NULL:仅仅可以判断NULL值，可读性较高，建议使用 &lt;=&gt;:既可以判断NULL值，又可以判断普通的数值，可读性较低 普通类型的数值 null值 可读性 is null × √ √ &lt;=&gt; √ √ ×","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"DQL语言————基础查询","slug":"Database02","date":"2020-06-09T12:07:58.000Z","updated":"2020-06-09T12:13:58.000Z","comments":true,"path":"2020/06/09/Database02/","link":"","permalink":"https://duvin0512.github.io./2020/06/09/Database02/","excerpt":"语法 特点 示例","text":"语法 特点 示例 基础查询1. 语法12select 查询列表from 表名; 2. 特点 查询列表可以是字段、常量、表达式、函数，也可以是多个 查询结果是一个虚拟表 3. 示例 查询单个字段 select 字段名 from 表名; 查询多个字段 select 字段名，字段名 from 表名; 查询所有字段 select * from 表名 查询常量 select 常量值; 注意：字符型和日期型的常量值必须用单引号引起来，数值型不需要 查询函数 select 函数名(实参列表); 查询表达式 select 100/1234; 起别名 as 空格 去重 select distinct 字段名 from 表名; + 作用：做加法运算 select 数值+数值; 直接运算 select 字符+数值; 先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成0，再做运算 select null+值; 结果都为null [补充] concat函数 功能：拼接字符 select concat(字符1，字符2，字符3,...); [补充] ifnull函数 功能：判断某字段或表达式是否为null，如果为null 返回指定的值，否则返回原本的值 select ifnull(commission_pct,0) from employees; [补充] isnull函数 功能：判断某字段或表达式是否为null，如果是，则返回1，否则返回0","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"数据库相关概念","slug":"Database01","date":"2020-06-08T06:47:45.000Z","updated":"2020-06-09T12:14:22.000Z","comments":true,"path":"2020/06/08/Database01/","link":"","permalink":"https://duvin0512.github.io./2020/06/08/Database01/","excerpt":"数据库的好处 数据库根本概念 数据库存储数据的特点 MySQL服务的启动和停止 MySQL服务的登录和退出 MySQL的常见命令 MySQL的语法规范 SQL的语言分类 SQL的常见命令","text":"数据库的好处 数据库根本概念 数据库存储数据的特点 MySQL服务的启动和停止 MySQL服务的登录和退出 MySQL的常见命令 MySQL的语法规范 SQL的语言分类 SQL的常见命令 MySQL基础数据库的好处 持久化数据到本地 可以实现结构化查询。方便管理 数据库根本概念 DB:数据库,保存一组有组织的数据的容器 DBMS:数据库管理系统。又称为数据库软件(产品),用于管理DB中的数据 SQL:结构化查询语言。用于和DBMS通信的语言 数据库存储数据的特点 将数据放到表中,表再放到库中 一个数据库中可以有多个表,每个表都有一个的名字,用来标识自己。表名具有唯一性。 表具有一些特性,这些特性定义了数据在表中如何存储，类似java中”类”的设计 表由列组成，也称为字段。所有表都是由一个或多个列组成的，每一列类似java中的”属性” 表中的数据是按行存储的，每一行类似于java中的”对象” MySQL服务的启动和停止 计算机-右击管理一服务 通过管理员身份运行 12net start 服务名(启动服务)net stop 服务名(停止服务) MySQL服务的登录和退出 通过mysql自带的客户端 只限于root用户 通过windows自带的客户端登录:mysql [-h主机名 -P端口号] -u用户名-p密码 退出：exit或ctrl+C MySQL的常见命令 查看当前所有的数据库show databases; 打开指定的库use 库名 查看当前库的所有表show tables; 查看其它库的所有表show tables from 库名; 创建表 1234create table 表名(列名列类型,列名列类型,); 查看表结构desc 表名; 查看服务器的版本 登录到mysq1服务端select version(); 没有登录到mysq1服务端mysql --verslon或mysql --V MySQL的语法规范 不区分大小写,但建议关键字大写，表名、列名小写 每条命令最好用分号结尾 每条命令根据需要,可以进行缩进或换行 注释 123单行注释: #注释文字单行注释: --注释文字多行注释: &#x2F;* 注释文字 *&#x2F; SQL的语言分类DQL（Data Query Language）：数据查询语言 select DML(Data Manipulate Language):数据操作语言 insert 、update、delete DDL（Data Define Languge）：数据定义语言 create、drop、alter TCL（Transaction Control Language）：事务控制语言 commit、rollback SQL的常见命令show databases; 查看所有的数据库 use 库名; 打开指定的库 show tables; 显示库中的所有表 show tables from 库名; 显示指定库中的所有表 1234create table 表名( 字段名 字段类型, 字段名 字段类型); 创建表 desc 表名; 查看指定表的结构 select * from 表名; 显示表中的所有数据","categories":[{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"CSS样式04————浮动","slug":"Frontend07","date":"2020-06-08T03:40:09.000Z","updated":"2020-06-10T07:22:02.000Z","comments":true,"path":"2020/06/08/Frontend07/","link":"","permalink":"https://duvin0512.github.io./2020/06/08/Frontend07/","excerpt":"浮动 常见网页布局 清除浮动","text":"浮动 常见网页布局 清除浮动 1. 浮动( float)1.1 传统网页布局的三种方式网页布局的本质————用CSS来摆放盒子。把盒子摆放到相应位置 CSS提供了三种传统布局方式(简单说就是盒子如何进行排列顺序): 普通流(标准流) 浮动 定位 这三种布局方式都是用来摆放盒子的,盒子摆放到合适位置。布局自然就完成了。 注意:实际开发中,一个页面基本都包含了这三种布局方式。 1.2 标准流(普通流/文档流)所谓的标准流就是标签按照规定好默认方式排列 块级元素会独占一行。从上向下顺序排列。 常用元素:div, hr, p, h1~h6, ul, ol, dl, form, table 行内元素会按照顺序,从左到右顺序排列.碰到父元素边缘则自动换行。 常用元素:span, a, i, em等 以上都是标准流布局,前面学习的就是标准流,标准流是最基本的布局方式。","categories":[{"name":"前端","slug":"前端","permalink":"https://duvin0512.github.io./categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://duvin0512.github.io./tags/HTML5/"},{"name":"CSS3","slug":"CSS3","permalink":"https://duvin0512.github.io./tags/CSS3/"}]},{"title":"CSS样式03————盒子模型","slug":"Frontend06","date":"2020-06-07T06:30:47.000Z","updated":"2020-06-08T03:41:28.000Z","comments":true,"path":"2020/06/07/Frontend06/","link":"","permalink":"https://duvin0512.github.io./2020/06/07/Frontend06/","excerpt":"盒子模型 圆角边框 盒子阴影 文字阴影","text":"盒子模型 圆角边框 盒子阴影 文字阴影 1. 盒子模型1.1 看透网页布局的本质网页布局过程: 先准备好相关的网页元素。网页元素基本都是盒子Box. 利用CSS设置好盒子样式,然后摆放到相应位置， 往盒子里面装内容， 网页布局的核心本质:就是利用CSS摆盒子。 1.2 盒子模型( Box Model )组成所谓盒子模型:就是把HTML页面中的布局元素看作是一个矩形的盒子,也就是一个盛装内容的容器。 CSS盒子模型本质上是一个盒子。封装周围的HTML元素,它包括:边框、外边距、内边距、和实际内容 1.3 边框(border)border可以设置元素的边框。边框有三部分组成边框宽度(粗细)、边框样式、边框颜色。 border: border-width | border-style | border-color 属性 作用 border-width 定义边框粗细,单位是px border-style 边框的样式 border-color 边框颜色 CSS 边框属性允许你指定一个元素边框的样式和颜色。 边框简写: border: 1px solid red;没有顺序 边框分开写法: border-top: 1px solid red; /* 只设定上边框，其余同理 */ 1.4 表格的细线边框border-collapse属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。 border-col1apse: collapse; border-collapse: collapse;表示相邻边框合并在一起 1.5 边框会影响盒子实际大小边框会额外增加盒子的实际大小。 测量盒子大小的时候不量边框. 如果测量的时候包含了边框,则需要width/height减去边框宽度 1.6 内边距(padding)padding属性用于设置内边距,即边框与内容之间的距离。 属性 作用 padding-left 左内边距 padding-right 右内边距 padding-top 上内边距 padding- bottom 下内边距 padding属性(简写属性)可以有一到四个值。 值的个数 表达意思 padding: 5px; 1个值，代表上下左右都有5像素内边距 padding: 5px 10px; 2个值，代表上下内边距是5像素左右内边距是10像素: padding: Spx 10px 20px; 3个值, 代表上内边距5像素左右内边距10像索 下内边距20像索; padding: 5px 10px 20px 30px; 4个值，上是5像素 右10像素下20像素左是30像素顺时针 当给盒子指定padding值之后,发生了2件事情: 内容和边框有了距离,添加了内边距。 padding影响了盒子实际大小。 也就是说，如果盒子已经有了宽度和高度,此时再指定内边框,会撑大盒子。 解决方案: 如果保证盒子跟效果图大小保持一致,则让width/height减去多出来的内边距大小如可。 如果盒子本身没有指定width/height属性,则此时padding不会撑开盒子大小 1.7 外边距(margin)margin属性用于设置外边距,即控制盒子和盒子之间的距离。 属性 作用 margin-left 左外边距 margin-right 右外边距 margin-top 上外边距 margin-bottom 下外边距 margin简写方式代表的意义跟padding完全一致。 外边距典型应用 外边距可以让块圾盒子水平居中,但是必须满足两个条件: 盒子必须指定了宽度(width) 盒子左右的外边距都设置为auto 1.header&#123; width:960px; margin:0 auto;&#125; 常见的写法,以下三种都可以: margin-left: auto; margin-right auto; margin: auto; margin: 0 auto; 注意:以上方法是让块级元素水平居中。行内元素或者行内块元素水平居中使其父元素添加text-align:center即可。 1.8 外边距合并使用margin定义块元素的重直外边距时,可能会出现外边距的合并。 1. 相邻块元素垂直外边距的合并当上下相邻的两个块元素(兄弟关系)相遇时,如果上面的元素有下外边距margin-bottom,下面的元素有上外边距margin-top ,则他们之间的重直间距不是margin-bottom与margin-top之和。取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合井。 解决方案: 尽量只给一个盒子添加margin值。 2. 嵌套块元素垂直外边距的塌陷对于两个嵌套关系(父子关系)的块元素,父元素有上外边距同时子元素也有上外边距,此时父元素会塌陷较大的外边距值。 解决方案: 可以为父元素定义上边框。 可以为父元素定义上内边距。 可以为父元素添加owerflow:hidden. 还有其他方法,比如浮动、固定,绝对定位的盒子不会有塌陷问题 1.9 清除内外边距网页元素很多都带有默认的内外边距,而且不同浏览器默认的也不一致。因此在布局前,首先要清除下网页元素的内外边距。 1234* &#123;padding:0; /* 清除内边距*/margin:0; /* 清除外边距*/&#125; 注意:行内元素为了照顾兼容性,尽量只设置左右内外边距,不要设置上下内外边距。但是转换为块级和行内块元素就可以了 2.圆角边框(重点)border-radius属性用于设置元素的外边框圆角。 border-radiua :length; radius半径(圆的半径)原理: (椭)圆与边框的交集形成圆角效果 参数值可以为数值或百分比的形式 如果小正方形,想要设置为一个圆,把数值修改为高度或者宽度的一半即可,或者直接写为50% 如果是个矩形,设置为高度的一半就可以做 该属性是一个简写属性,可以跟四个值,分别代表左上角、右上角、右下角、左下角 分开写: border-top-left-radius,border-top-right-radius,border-bottom-right-radius和border-bottom-left-radius 3. 盒子阴影(重点)CSS3中新增了盒子阴影。可以使用box- shadow属性为盒子添加阴影。 box-shadow: h-shadow v-shadow blur spread color inset; 值 描述 h-shadow 必需。水平胡影的位置。允许负值, v-shadow 必需。重直阴影的位置。允许负值。 blur 可选。横糊距离， spread 可选。阴影的尺寸。 color 可选。阴影的颜色，请参阅CSsS颜色值， inset 可选。将外部阴影(outset)改为内部阴影。 注意: 默认的是外阴影(outset).但是不可以写这个单词否则导致阴影无效 盒子阴影不占用空间,不会影响其他盒子排列。 6. 文字阴影在CSS3中,可以使用text-shadow属性将阴影应用于文本。 text-shadow: h-shadow v-shadow blur color; 值 描述 h-shadow 必需。水平阴影的位置，允许负值。 v-shadow 必需，垂直阴影的位置，允许负值。 blur 可选。模糊的距离。 color 可选。阴影的颜色。参阅CSsS颜色值。","categories":[{"name":"前端","slug":"前端","permalink":"https://duvin0512.github.io./categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://duvin0512.github.io./tags/HTML5/"},{"name":"CSS3","slug":"CSS3","permalink":"https://duvin0512.github.io./tags/CSS3/"}]},{"title":"CSS3样式02","slug":"Frontend05","date":"2020-06-04T03:19:17.000Z","updated":"2020-06-07T06:26:52.000Z","comments":true,"path":"2020/06/04/Frontend05/","link":"","permalink":"https://duvin0512.github.io./2020/06/04/Frontend05/","excerpt":"Emmet语法 CSS的复合选择器 CSS的元素显示模式 CSS的背景 CSS的三大特性","text":"Emmet语法 CSS的复合选择器 CSS的元素显示模式 CSS的背景 CSS的三大特性 1. Emmet语法1.1 快速生成HTML结构语法 生成标签直接输入标签名按tab健即可,比如div然后tab键。就可以生成&lt;div&gt; &lt;/div&gt; 如果想要生成多个相同标签加上*就可以了比如div*3,就可以快速生成3个div 如果有父子级关系的标签,可以用&gt;比如ul&gt;li就可以了 如果有兄弟关系的标签,用+就可以了比如div+p 如果生成带有类名或者id名字的,直接写.demo 或者#two tab键就可以了 如果生成的div类名是有顺序的,可以用自增符号$ 如果想要在生成的标签内部写内容可以用{}表示 1.2 快速生成CSS样式语法CSS基本采取简写形式即可。 比如w200按tab可以生成width: 200px 比如lh26按tab可以生成line-height: 26px; 1.3 快速格式化代码Vscode快速格式化代码: shift+alt+f 也可以设置当保存页面的时候自动格式化代码: 1)文件—–&gt;[首选项]——-&gt;[设置];2)搜索emmet.include;3)在settings.json下的[用户]中添加以下语句: 12&quot;editor.formatOnType&quot;: true,&quot;editor.formatOnSave&quot;: true 只需要设置一次即可,以后都可以自动保存格式化代码 2. CSS的复合选择器2.1 什么是复合选择器在CSS中,可以根据选择器的类型把选择器分为基础选择器和复合选择器,复合选择器是建立在基础选择器之上,对基本选择器进行组合形成的。 复合选择器可以更准确,更高效的选择目标元素(标签) 复合选择器是由两个或多个基础选择器。通过不同的方式组合而成的 常用的复合选择器包括:后代选择器、子选择器、并集选择器、伪类选择器等等 2.2 后代选择器(重要)后代选择器又称为包含选择器,可以选择父元素里面子元素。其写法就是把外层标签写在前面,内层标签写在后面,中间用空格分隔。当标签发生嵌套时,内层标签就成为外层标签的后代。 元素1 元素2 { 样式声明 } 上述语法表示选择元素1里面的所有元素2 (后代元素)。 1ul li &#123; 样式声明 &#125; /*选择ul里面所有的1i标签元素*/ 元素1和元素2中间用空格隔开 元素1是父级,元素2是子级,最终选择的是元素2 元素2可以是儿子。也可以是孙子等。只要是元素1的后代即可 元素1和元素2可以是任意基础选择器 2.3 子选择器(重要)子元素选择器(子选择器)只能选挥作为某元素的最近一级子元素。简单理解就是选亲儿子元素. 元素1 &gt; 元素2 { 样式声明 } 上述语法表示选择元素1里面的所有直接后代(子元素)元素2. 1div &gt; P&#123; 样式声明 &#125;/*选择div里面所有最近一级P标签元素*/ 元素1和元素2中间用大于号隔开 元素1是父级,元素2是子级,最终选择的是元索2 元素2必须是亲儿子,其孙子、重孙之类都不归他管 2.4 并集选择器(重要)并集选择器可以选择多组标签同时为他们定义相同的样式。通常用于集体声明 并集选择器是各选择器通过英文逗号(.)连接而成,任何形式的选择器都可以作为并集选择器的一部分。 元素1,元素2 { 样式声明 } 上述语法表示选择元素1和元素2。 1ul,div &#123; 样式声明 &#125; /* 选择ul和div标签元素 */ 元素1和元素2中间用逗号隔开 逗号可以理解为和的意思 并集选择器通常用于集体声明 2.5 伪类选择器伪类选择器用于向某些选择器添加特殊的效果,比如给链接添加特殊效果,或选择第1个,第n个元素。 伪类选择器书写最大的特点是用冒号(:)表示,比如:hover、:first-child. 2.6 链接伪类选择器1234a:link /*选择所有未被访问的链接*/a:visited /*选择所有已被访问的链接。*/a:hover /*选择鼠标指针位于其上的链接*/a:active /*选择活动链接(鼠标按下未弹起的链接)*/ 链接伪类选择器注意事项 为了确保生效,请按照LVHA的循顺序声明:link,visited,hover,active. 记忆法:love hate或者lv包包hao. 因为a链接在浏览器中具有默认样式,所以实际工作中都需要给链接单独指定样式。 链接伪类选择器实际工作开发中的写法: 123456789/* a是标签选择器 所有的链接*/a &#123; color: gray;&#125;/* :hover是链接伪类选择器鼠标经过*/a:hover &#123;color: red; /*鼠标经过的时候，由原来的灰色变成了红色。*/&#125; 2.7 focus伪类选择器:focus伪类选择器用于选取获得焦点的表单元素。 焦点就是光标,一般情兄&lt;input&gt;类表单元素才能获取,因此这个选择器也主要针对于表单元素来说。 123input: focus &#123;background-color: yellow;&#125; 3. CSS的元素显示模式3.1 什么是元素显示模式作用:网页的标签非常多,在不同地方会用到不同类型的标签,了解他们的特点可以更好的布局我们的网页。 元素显示模式就是元素(标签)以什么方式进行显示,比如&lt;div&gt;自己占一行, 比如一行可以放多个&lt;span&gt;. HTML元素一般分为块元素和行内元素两种类型。 3.2 块元素常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等,其中&lt;div&gt;标签是最典型的块元素。 块级元素的特点: 自己独占-行。 高度，宽度、外边距以及内边距都可以控制。 宽度默认是容器(父级宽度)的100%。 是一个容器及盒子。里面可以放行内或者块级元素。 注意: 文字类的元素内不能使用块级元素 &lt;p&gt;标签主要用于存放文字。因此&lt;p&gt;里面不能放块级元素,特别是不能放&lt;div&gt; 同理，&lt;h1&gt;-&lt;h6&gt;等都是文字类块极标签,里面也不能放其他块级元素 3.3 行内元素常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等。其中&lt;span&gt;标签是最典型的行内元素。有的地方也将行内元素称为内联元素。 行内元素的特点: 相邻行内元素在一行上,一行可以显示多个。 高、宽直接设置是无效的。 默认宽度就是它本身内容的宽度。 行内元素只能容纳文本或其他行内元素。 注意: 链接里面不能再放链接 特殊情况链接&lt;a&gt;里面可以放块级元素。但是给&lt;a&gt;转换一下块级模式最安全 3.4 行内块元素在行内元素中有几个特殊的标签&lt;img/&gt;、&lt;input/&gt;、&lt;td&gt;,它们同时具有块元素和行内元素的特点。有些资料称它们为行内块元素。 行内块元素的特点: 和相邻行内元素(行内块)在一行上,但是他们之间会有空白缝随。一行可以显示多个(行内元素特点). 默认宽度就是它本身内容的宽度(行内元素特点)。 高度、行高、外边距以及内边距都可以控制(块级元素特点)。 3.5 元素显示模式转换特殊情况下,我们需要元素模式的转换简单理解: 一个模式的元素需要另外一种模式的特性 比如想要增加链接&lt;a&gt;的触发范围。 转换为块元素: display: block; 转换为行内元素: display: inline; 转换为行内块: display: inline-block; 3.6 一个小技巧 单行文字垂直居中的代码CSS没有提供文字垂直居中的代码。这里可以使用一个小枝巧来实现 解决方案:让文字的行高等于盒子的高度就可以让文字在当前盒子内垂直居中 4. CSS的背景通过CSS背景属性,可以给页面元素添加背景样式。 背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。 4.1 背景颜色background-color属性定义了元素的背景颜色。 background-color:颜色值; 一般情况下元素背景颜色默认值是transparent(透明),也可以手动指定背景颜色为透明色。 4.2 背景图片background image属性描述了元素的背景图像。实际开发常见于logo或者一些装饰性的小图片或者是超大的背景图片,优点是非常便于控制位置(精灵图也是一种运用场景) background-image : none | url (url) 参数值 怍用 none 无背景图(默认的) url 使用绝对或相对地址指定背晨图像 4.3 背景平铺如果需要在HTML页面上对背景图像进行平铺。可以使用background-repeat属性。 background-repeat: repeat | no-repeat | repeat-x | repeat-y 参数值 怍用 repeat 背景图像在纵向和横向上平铺(默认的) no-repeat 背景图像不平铺 repeat-x 背最图像在横向上平铺 repeat-y 背景图像在纵向平铺 4.4 背景图片位置利用background position属性可以改变图片在背景中的位置。 background-position: x y; 参数代表的意思是: x坐标和y坐标。可以使用方位名词或者精确单位 参数值 说明 length 百分数 position top 、 center 、 bottom 、 left 、 center 、 right方位名词 参数是方位名词 如果指定的两个值都是方位名词,则两个值前后顺序无关,比如left top和top left效果一致 如果只指定了一个方位名词,另一个值省略,则第二个值默认居中对齐 参数是精确单位 如果参数值是精确坐标 ,那么第一个肯定是x坐标,第二个一定是y坐标 如果只指定一个数值。那该数值一定是x坐标,另一个默认重直居中 参数是混合单位 如果指定的两个值是精确单位和方位名词混合使用, 则第一个值是x坐标,第二个值是y坐标 4.5 背景图像固定(背景附着)background attachment属性设置背景图像是否固定或者随着页面的其余部分滚动。 background-attachment后期可以制作视差滚动的效果。 background-attachment : scroll | fixed 参数 作用 scroll 背景图像是随对象内容滚动 fixed 背景图像固定 4.6 背景复合写法为了简化背景属性的代码,我]可以将这些属性合并简写在同个属性background中.从而节约代码量 当使用简写属性时,没有特定的书写顺序,一般习惯固定顺序为: background: 背景颜色 背景图片地址 背景平铺背置图像滚动 背景图片位置; background: transparent url(image.jpg) repeat-y fixced top; 这是实际开发中更提倡的写法。 4.7 背景色半透明CSS3提供了背景颜色半透明的效果。 background: rgba(O, 0, 0, 0.3); 最后一个参数是alpha透明度,取值范围在0~1之间 习惯把0.3的 0省略掉,写为background:rgba(0,0,0, .3) 注意:背景半透明是指盒子背景半透明，盒子里面的内容不受影响 5. CSS的三大特性5.1 层叠性CSS有三个非常重要的三个特性:层叠性、继承性、优先级。 相同选择器给设置相同的样式,此时一个样式就会覆盖(层叠)另一个冲突的样式。层叠性主要解决样式冲突的问题 层叠性原则: 样式冲突,遵循的原则是就近原则,哪个样式离结构近,就执行哪个样式 样式不冲突，不会层叠 5.2 继承性CSS中的继承子标签会继承父标签的某些样式,如文本颜色和字号。 恰当地使用继承可以简化代码,降低CSS样式的复杂性 子元素可以继承父元素的样式 ( text-,font-,line-这些元素开头的可以继承,以及color属性) 行高的继承性 123body &#123; font:12px/1.5 'Microsoft YaHei' ;&#125; 行高可以跟单位也可以不跟单位 如果子元素没有设置行高,则会继承父元素的行高为1.5 此时子元素的行高是: 当前子元素的文字大小* 1.5 body行高1.5这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高 5.3 优先级选择器权重如下表所示。 选择器 选择器权重 继承或者* 0,0,0,0 元素选择器 0,0,0,1 类选择器,伪类选择器 0,0,1,0 ID选择器 0,1,0,0 行内样式syle=” 1,0,0,0 important重要的 ∞无穷大 优先级注意点: 权重是有4组数字组成但是不会有进位。 可以理解为类选择器永远大于元素选择器 id选择器永远大于类选择器以此类推。 等级判断从左向右,如果某一位数值相同,则判断下一位数值。 可以简单记忆法:通配符和继承权重为0,标签选择器为1.类(伪类)选择器为10, id选择器100,行内样式表为1000, !important无穷大. 继承的权重是0.如果该元素没有直接选中.不管父元素权重多高,子元素得到的权重都是0. 权重叠加:如果是复合选择器,则会有权重叠加,需要计算权重。 div ul li ————&gt; 0,0,0,3 .nav ul li ————&gt; 0,0,1,2 a:hover ————&gt; 0,0,1,1 .nav a ————&gt; 0,0,1,1","categories":[{"name":"前端","slug":"前端","permalink":"https://duvin0512.github.io./categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://duvin0512.github.io./tags/HTML5/"},{"name":"CSS3","slug":"CSS3","permalink":"https://duvin0512.github.io./tags/CSS3/"}]},{"title":"CSS3样式01","slug":"Frontend04","date":"2020-06-03T06:29:02.000Z","updated":"2020-06-03T09:19:44.000Z","comments":true,"path":"2020/06/03/Frontend04/","link":"","permalink":"https://duvin0512.github.io./2020/06/03/Frontend04/","excerpt":"CSS基础选择器 CSS字体属性 CSS文本属性 CSS引入方式","text":"CSS基础选择器 CSS字体属性 CSS文本属性 CSS引入方式 1. CSS简介1.3 CSS语法规范CSS规则由两个主要的部分构成:选择器以及一条或多条声明。 选择器是用于指定CSS样式的HTML标签,花括号内是对该对象设置的具体样式 属性和属性值以“键值对”的形式出现 属性是对指定的对象设置的样式属性,例如字体大小、文本颜色等 属性和属性值之间用英文“：”分开 多个“键值对”之间用英文“；” 进行区分 2.CSS基础选择器2.1 CSS选择器的作用选择器(选择符)就是根据不同需求把不同的标签选出来这就是选择器的作用。简单来说,就是选择标签用的。 2.2 选择器分类选择器分为基础选择器和复合选择器两个大类,先了解一下基础选择器。 基础选择器是由单个选择器组成的 基础选择器又包括:标签选择器、类选择器、id选择器和通配符选择器 2.3 标签选择器标签选择器(元素选择器)是指用HTML标签名称作为选择器,按标签名称分类,为页面中某一类标签指定统一的CSS样式。 作用标签选择器可以把某一类标签全部选择出来,比如所有的&lt;div&gt;标签和所有的&lt;span&gt;标签。 优点能快速为页面中同类型的标签统一设置样式。 缺点不能设计差异化样式,只能选择全部的当前标签。 2.4 类选择器如果想要差异化选择不同的标签,单独选一个或者某几个标签,可以使用类选择器 123.类名&#123;属性1: 属性值1;&#125; 结构需要用class属性来调用class类的意思 &lt;div class-&#39;red&#39;&gt;变红色&lt;/div&gt; 类选择器在HTML中以class属性表示，在CSS中,类选择器以一个点”.” 号显示 注意 类选择器使用”.”( 英文点号)进行标识,后面紧跟类名(自定义,自己命名的) . 可以理解为给这个标签起了一个名字,来表示。 长名称或词组可以使用中横线来为选择器命名。 不要使用纯数字、中文等命名,尽量使用英文字母来表示 命名要有意义。尽量使别人一跟就知道这个类名的目的。 记忆口诀:样式点定义,结构类调用。一个或多个,开发最常用。 2.4.1 多类名 多类名使用方式 &lt;div class=&quot;red font20&quot;&gt;亚瑟&lt;/div&gt; (1)在标签class属性中写多个类名(2)多个类名中间必须用空格分开(3)这个标签就可以分别具有这些类名的样式 多类名开发中使用场景 (1)可以把一些标签元素相同的样式(共同的部分)放到一个类里面.(2)这些标签都可以调用这个公共的类然后再调用自己独有的类.(3)从而节省CSS代码统一修改也非常方便 2.5 id选择器id选择器可以为标有特定id的HTML元素指定特定的样式。 HTML元素以id属性来设置id选择器, CSS中id选择器以“#”来定义。 #id名{ 属性1: 属性值1; } 例如,将id为nav元素中的内容设置为红色。 #nav { color: red; } 注意:id属性只能在每个HTML文档中出现一次。口诀:样式#定义,結构id调用,只能调用一次,别人切勿使用。 id选择器和类选择器的区别 类选择器(class)好比人的名字,一个人可以有多个名字,同时一个名字也可以被多个人使用。 id选择器好比人的身份证号码,全中国是唯一的,不得重复。 id选择器和类选择器最大的不同在于使用次数上。 类选择器在修改样式中用的最多,id选择器一般用于页面唯一性的元素上。经常和JavaScript搭配使用。 2.6 通配符选择器在CSS中,通配符选择器使用“*”定义,它表示选取页面中所有元素(标签) . *{ 属性1:属性值1; } 通配符选择器不需要调用，目动就给所有的元素使用样式 特殊情况才使用,后面讲解使用场景以下是清除所有的元素标签的内外边距 * { margin: 0; paddingt 0; } 3. CSS字体属性CSS Fonts(字体)属性用于定义字体系列，大小粗细、和文字样式(如斜体)。 3.1 字体系列CSS使用font-family属性定义文本的字体系列。 12P &#123; font-family: \"微软雅黑\";&#125;div &#123;font- family: Arial, \"Microsoft Yahei\", \"微软雅黑\";&#125; 各种字体之间必须使用英文状态下的逗号隔开 一般情况下，如果有空格隔开的多个单词组成的字体加引号. 尽量使用系统默认自带字体,保证在任何用户的浏览器中都能正确显示 最常见的几个字体: body(font family, “Microsoft YaHei”,tahoma,arial,’HiraginoSans GB’;} 3.2 字体大小CSS使用font-size属性定义字体大小。 123P &#123; font-size: 20px;&#125; px(像素)大小是我们网页的最常用的单位 谷歌浏览器默认的文字大小为16px 不同浏览器可能默认显示的字号大小不一致,我们尽量给一个明确值大小,不要默认大小 可以给body指定整个页面文字的大小 3.3 字体粗细CSS使用font-welight属性设置文本字体的粗细。 123P &#123; font-weight: bold;&#125; 属性值 描述 normal 默认值(不加粗的) bold 定义粗体(加粗的) 100-900 400 等同于normal,而700等同于bold 注意这个数字后面不跟单位 3.4 文字样式CSS使用font-style属性设置文本的风格。 123P &#123; font-style: normal;&#125; 属性值 作用 normal 默认值，浏览器会显示标准的字体样式font-style: normal; italic 浏览器会显示斜体的字体样式。 注意:平时我们很少给文字加斜体,反而要给斜体标签(em,i)改为不倾斜字体。 3.5 字体复合属性字体属性可以把以上文字样式综合来写，这样可以更节约代码 123body &#123; font: font-style font-weight font-size/line-height font-family;&#125; 使用font属性时,必须按上面语法格式中的顺序书写。不能更换顺序,并且各个属性间以空格隔开 不需要设置的属性可以省略(取默认值),但必须保留font-size和font-family属性,否则font属性将不起作用 4. CSS文本属性CSS Text(文本)属性可定义文本的外观,比如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等。 4.1 文本颜色color属性用于定义文本的颜色。 123div &#123;color: red;&#125; 表示表示 属性值 预定义的颜色值 red,green,blue,pink 十六进制 #FF000O,#FF6600,#29D794 RGB代码 r(255,0.0)或(g(1006.0%,09%0) 开发中最常用的是十六进制 4.2 对齐文本text-align属性用于设置元素内文本内容的水平对齐方式。 123div &#123; text-align: center;&#125; 属性值 解释 left 左对齐(默认值) right 右对齐 center 居中对齐 4.3 装饰文本text-decoration属性规定添加到文本的修饰。可以给文本添加下划线、删除线、上划线等。 123div &#123; text-decoration: underline;&#125; 属性值 | 描述none | 默认。没有装饰线(最常用)underline | 下划线。链接a自带下划线(常用)overline | 上划线。(几乎不用)line through | 删除线。(不常用) 4.4 文本缩进text-indent属性用来指定文本的第一行的缩进,通常是将段落的首行缩进。 123div &#123; text- indent: 10px;&#125; 通过设置该属性,所有元素的第一行都可以缩进一个给定的长度 ,甚至该长度可以是负值。 123P &#123; text-indent: 2em;&#125; em是一个相对单位,就是当前元素(font-size)1个文字的大小，如果当前元素没有设置大小，则会按照父元素的1个文字大小。 4.5 行间距line-height属性用于设置行间的距离(行高)。可以控制文字行与行之间的距离。 123P &#123; line-height: 26px;&#125; 5. CSS引入方式5.1 CSS的三种样式表按照CSS样式书写的位置(或者引入的方式),CSS样式表可以分为三大类: 行内样式表(行内式) 内部样式表(嵌入式) 外部样式表(链接式) 内部样式表(内嵌样式表)是写到html页面内部是将所有的CSS代码抽取出来.单独放到一个&lt;style&gt;标签中。 123456&lt;style&gt; div &#123; color: red; font-size: 12px; &#125;&lt;/style&gt; &lt;style&gt; 标签理论上可以放在HTML文档的任何地方,但般会放在文档的&lt;head&gt;标签中 通过此种方式,可以方便控制当前整个页面中的元素样式设置 代码结构清晰。但是并没有实现结构与样式完全分离 使用内部样式表设定 CSS ,通常也被称为嵌入式引入 行内样式表(内联样式表)是在元素标签内部的style属性中设定CSS样式。适合于修改简单样式 &lt;div stylem&quot;color: red; font-size: 12px;&quot;&gt;青春不常在，抓紧谈恋爱&lt;/div&gt; style其实就是标签的属性 在双引号中间,写法要符合CSS规范 可以控制当前的标签设置样式 由于书写繁琐,并且没有体现出结构与样式相分离的思想,所以不推荐大量使用,只有对当前元素添加简单样式的时候,可以考虑使用 使用行内样式表设定CSS,通常也被称为行内式引入 5.4 外部样式表实际开发都是外部样式表。适合于样式比较多的情况核心是:样式单独写到CSS文件中,之后把CSS文件引入到HTML页面中使用 引入外部样式表分为两步: 新建一个后缀名为.CSS的样式文件,把所有CSS代码都放入此文件中。 在HTML页面中,使用&lt;link&gt;标签引入这个文件。 &lt;link rel=&quot;stylesheet&quot; href=&quot;css文件路径&quot;&gt; 属性 作用 rel 定义当前文档与被链接文档之间的关系。在这里需要指定为”stylesheet”, 表示被链接的文档是一个样式表文件。 href 定义所链接外部样式表文件的URL,可以是相对路径，也可以是绝对路径。 使用外部样式表设定CSS ,通常也被称为外链式或链接式引入，这种方式是开发中常用的方式","categories":[{"name":"前端","slug":"前端","permalink":"https://duvin0512.github.io./categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://duvin0512.github.io./tags/HTML5/"},{"name":"CSS3","slug":"CSS3","permalink":"https://duvin0512.github.io./tags/CSS3/"}]},{"title":"前端02-HTML标签(下)","slug":"Frontend03","date":"2020-06-01T12:49:12.000Z","updated":"2020-06-03T06:38:42.000Z","comments":true,"path":"2020/06/01/Frontend03/","link":"","permalink":"https://duvin0512.github.io./2020/06/01/Frontend03/","excerpt":"书写表格 无序列表 常用input表单类型 下拉列表表单 使用表单元素实现注册页面 查阅W3C文档","text":"书写表格 无序列表 常用input表单类型 下拉列表表单 使用表单元素实现注册页面 查阅W3C文档 1 表格标签1.1 表格的基本语法1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ...&lt;/table&gt; &lt;table&gt; &lt;/table&gt;是用于定义表格的标签。 &lt;tr&gt; &lt;/tr&gt;标签用于定义表格中的行.必须嵌套在&lt;table&gt; &lt;/table&gt;标签中。 &lt;td&gt; &lt;/td&gt;用于定义表格中的单元格,必须嵌套在&lt;tr&gt; &lt;/tr&gt;标签中。 字母td指表格数据table data) ,即数据单元格的内容。 1.2 表头单元格标签一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容加相居中显示. &lt;th&gt;标签表示HTML表格的表头部分(table head的缩写) 12345&lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; 1.3 表格属性表格标签这部分属性实际开发不常用,后面通过CSS来设置. 属性名 属性值 描述 align left. center. right 规定表格相对周围元素的对齐方式。 border 1或- 规定表格单元是否拥有边框，默认为””，表示没有边框 elladding 像素值 规定单元边汨与其内容之间的空白，默认1像素。 cellspacing 像素值 规定单元格之间的空白，默认2像素。 width 像素值或百分比 规定表格的宽度。 1.4 表格结构标签 &lt;thead&gt; &lt;/thead&gt;:用于定义表格的头部。&lt;thead&gt;内部必须拥有&lt;tr&gt;标签。一般是位于第一行。 &lt;tbody&gt; &lt;/tbody&gt;:用于定义表格的主体,主要用于放数据本体。 以上标签都是放在&lt;table&gt; &lt;/table&gt;标签中。 1.5 合并单元格合并单元格方式: 跨行合并: rowspan=”合并单元格的个数” 跨列合并: colspan=’合并单元格的个数” 目标单元格:(写合并代码) 跨行:最上侧单元格为目标单元格,写合井代码 跨列:最左侧单元格为目标单元格写合井代码 合并单元格三步曲: 先确定是跨行还是跨列合并。 找到目标单元格写上合井方式=合并的单元格数量。比如: &lt;tdcolspan= &quot;2&quot; &gt; &lt;/td&gt;。 删除多余的单元格。 2. 列表标签2.1 无序列表(重点)&lt;ul&gt;标签表示HTML页面中项目的无序列表,一般会以项目符号呈现列表项,而列表项使用&lt;li&gt;标签定义。 12345&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt;&lt;/ul&gt; 无序列表的各个列表项之间没有顺序级别之分,并列的。 &lt;ul&gt; &lt;/ul&gt;只能嵌套&lt;li&gt;&lt;/li&gt;,直接在&lt;ul&gt; &lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。 &lt;li&gt;与&lt;/li&gt;之间相当于一个容器,可以容纳所有元素。 无序列表会带有自己的样式属性，但在实际使用时，我们会使用CSS来设置。 2.2 有序列表(理解)在HTML标签中，&lt;ol&gt; 标签用于定义有序列表,列表排序以数字来显示,并且使用&lt;li&gt;标签来定义列表项。 12345&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt;&lt;/ol&gt; &lt;ol&gt; &lt;/ol&gt;中只能嵌套&lt;li&gt; &lt;/li&gt; , 直接在&lt;ol&gt;&lt;/ol&gt;标签中输入其他标签或者文字的做法是不被允许的。 &lt;li&gt; 与&lt;/li&gt;之间相当于一个容器,可以容纳所有元素。 有序列表会带有自己样式属性,但在实际使用时，我们会使用CSS来设置。 2.3自定义列表(重点)在HTML标签中，&lt;dl&gt;标签用于定义描述列表(或定义列表) , 该标签会与&lt;dt&gt;(定义项目/名字)和&lt;dd&gt; (描述每一个项目/名字)一起使用。 12345&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt;&lt;/dl&gt; &lt;dl&gt; &lt;/dl&gt;里面只能包含&lt;dt&gt;和&lt;dd&gt;. &lt;dt&gt; 和&lt;dd&gt;个数没有限制,经常是一个&lt;dt&gt;对应多个&lt;dd&gt;. 3. 表单标签收集用户信息 3.1 表单的组成在HTML中, 一个完整的表单通常由表单域、表单控件(也称为表单元素)和提示信息3个部分构成。 3.2 表单域表单域是一个包含表单元素的区域。 在HTML标签中，&lt;form&gt; 标签用于定义表单域,以实现用户信息的收集和传递。 &lt;form&gt;会把它范围内的表单元素信息提交给服务器。 123&lt;form action=\"url地址\" method=\"提交方式\" name=\"表单域名称\"&gt; 各种表单元素控件&lt;/form&gt; 属性 属性值 作用 action url地址 用于指定接收并处理表单数据的服务器程序的url地址。 method get/post 用于设置表单数据的提交方式，其取值为get或post。 name 名称 用于指定表单的名称，以区分同一个页面中的多个表单域。 3.3 表单控件(表单元素)在表单域中可以定义各种表单元素,这些表单元素就是允许用户在表单中输入或者选择的内容控件。 3.3.1 &lt;input&gt;表单元素在表单元素中&lt;input&gt;标签用于收集用户信息。 在&lt;input&gt;标签中,包含一个type属性,根据不同的type属性值,输入字段拥有很多种形式(可以文本字段、复选框、掩码后的文本控件、单选按钮、按钮等)。 &lt;input type=&quot;属性值&quot; /&gt; &lt;input /&gt;标签为单标签 type属性设置不同的属性值用来指定不同的控件类型 type属性的属性值及其描述如下: 属性值 描述 button 定义可点击按钮(多数情况下，用于通过JavaScript启动脚本)。 checkbox 定义复选框。 file 定义输入字段和“浏览”按钮，供文件上传。 hidden 定义隐藏的输入字段。 image 定义图像形式的提交按钮。 password 定义密码字段。该字段中的字符被掩码。 radio 定义单选按钮。 reset 定义重置按钮。重置按钮会清除表单中的所有数据。 submit 定义提交按钮。提交按钮会把表单数据发送到服务器。 text 定义单行的输入字段，用户可在其中输入文本。默认宽度为20个字符。 除type属性外, &lt;input&gt;标签还有其他很多属性,其常用属性如下: 属性 属性值 描述 name 由用户自定义 定义input元素的名称。 value 由用户自定义 规定input元素的值。 checked checked 规定此input元素首次加载时应当被选中。 maxlength 正整数 规定输入字段中的字符的最大长度。 name和value是每个表单元素都有的属性值主要给后台人员使用 name表单元素的名字，要求单选按钮和复选框要有相同的name值 checked属性主要针对于单选按钮和复选框主要作用一打开页面,就要可以默认选中某个表单元素 maxlength 是用户可以在表单元素输入的最大字符数,一般较少使用. 3.3.2 &lt;label&gt;标签&lt;label&gt;标签为input元素定义标注(标签)。 &lt;label&gt;标签用于绑定一个弹元素当点击&lt;label&gt;标签内的文本时,浏览器就会自动将焦点(光标转到或者选择对应的表单元素上用来增加用户体验. 12&lt;label for=\"sex\"&gt;男&lt;/label&gt;&lt;input type=\"radio\" name=\"sex\" id=\"sex\" /&gt; 核心: &lt;label&gt;标签的for属性应当与相关元素的id属性相同。 3.3.3 &lt;select&gt; 表单元素在页面中,如果有多个选项让用户选择,并且想要节页面空间时,可以使用&lt;select&gt;标签控件定义下拉列表. 123456&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ...&lt;/select&gt; &lt;select&gt;中至少包含一对&lt;option&gt; 在&lt;option&gt;中定义selected =”selected”时,当前项即为默认选中项。 3.3.4 &lt;textarea&gt;表单元素当用户输入内容较多的情况下,就不能使用文本框表单了,此时可以使用&lt;textarea&gt;标签。 在表单元素中,&lt;textarea&gt;标签是用于定义多行文本输入的控件。 使用多行文本输入控件,可以输入更多的文字,该控件常见于留言板,评论。","categories":[{"name":"前端","slug":"前端","permalink":"https://duvin0512.github.io./categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://duvin0512.github.io./tags/HTML5/"},{"name":"CSS3","slug":"CSS3","permalink":"https://duvin0512.github.io./tags/CSS3/"}]},{"title":"前端02-HTML标签(上)","slug":"Frontend02","date":"2020-05-30T08:00:20.000Z","updated":"2020-06-03T06:39:04.000Z","comments":true,"path":"2020/05/30/Frontend02/","link":"","permalink":"https://duvin0512.github.io./2020/05/30/Frontend02/","excerpt":"HTML语法规范 HTML基本结构标签 HTML常用标签 HTML中的注释和特殊字符","text":"HTML语法规范 HTML基本结构标签 HTML常用标签 HTML中的注释和特殊字符 1.HTML语法规范1.1 基本语法概述 HTML标签是由尖括号包围的关键词,例如&lt;html&gt;。 HTML标签通常是成对出现的,例妇&lt;html&gt;和&lt;/html&gt;,称为双标签。标签对中的第一个标签是开始标签,第二个标签是结束标签。 有些特殊的标签必须是单个标签(极少情况),例如&lt;br/&gt;,我们称为单标签。 1.2 标签关系双标签关系可以分为两类:包含关系和并列关系。 包含关系 123&lt;head&gt; &lt;title&gt; &lt;/title&gt;&lt;head&gt; 并列关系 123&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/head&gt; 2. HTML基本结构标签2.1 第一个HTML每个网页都会有一个基本的结构标签 (也称为骨架标签) ,页面内容也是在这些基本标签上书写。 标签名 定义 说明 &lt;html&gt;&lt;/html&gt; HTML标签 页面中最大的标签，称为根标签 &lt;head&gt;&lt;/head&gt; 文档的头部 注意在head标签中必须要设置的标签是title &lt;titile&gt;&lt;/title&gt; 文档的标题 让页面拥有一个属于自己的网页标题 &lt;body&gt;&lt;/body&gt; 文档的主体 元素包含文档的所有内容，页面内容基本都是放到body里面的 HTML文档的的后缀名必须是.html或.htm ,浏览器的作用是读取HTML文档,并以网页的形式显示出它们。 此时,用浏览器打开这个网页,就可以预览写的第一个HTML文件了。 2.2 基本结构标签总结 3.HTML常用标签3.1 标题标签&lt;h1&gt;-&lt;h6&gt;(重要)HTML 提供了6个等级的网页标题,即&lt;h1&gt;- &lt;h6&gt; &lt;h1&gt;我是一级标题&lt;/h1&gt; 标签语义:作为标题使用,并诅依据重要性减。 特点: 加了标题的文字会变的加粗,字号也会依次变大。 一个标题独占一行。 3.2 段落和换行标签(重要)在HTML标签中, &lt;p&gt; 标签用于定义段落 &lt;p&gt;我是一个段落标签&lt;/p&gt; 标签语义:可以把HTML文档分割为若干段落。 特点: 文本在一个段落中会根据浏览 器窗口的大小自动换行。 段落和段落之间保有空隙。 某段文本强制换行显示,需要使用换行标签&lt;br/&gt; &lt;br /&gt; 标签语义:强制换行。 特点: &lt;br/&gt;是个单标签。 &lt;br/&gt;标签只是简单地开始新的一行,跟段落不-样,段落之间会插入一些垂直的间距。 3.3 文本格式化标签标签语义:突出重要性,比普通文字更重要. 语义 标签 加粗 &lt;strong&gt;&lt;/strong&gt;或者&lt;b&gt;&lt;/b&gt; 倾斜 &lt;em&gt;&lt;/em&gt;或者&lt;i&gt;&lt;/i&gt; 删除线 &lt;del&gt;&lt;/del&gt;或者&lt;s&gt;&lt;/s&gt; 下划线 &lt;ins&gt;&lt;/ins&gt;或者&lt;u&gt;&lt;/u&gt; 3.4 &lt;div&gt;和&lt;span&gt;标签&lt;div&gt;和&lt;span&gt;是没有语义的,它们就是一个盒子,用来装内容的。 12&lt;div&gt;这是头部&lt;/div&gt;&lt;span&gt;今日价格&lt;/span&gt; 特点: &lt;div&gt;标签用来布局,但是现在一行只能放一个&lt;div&gt;大盒子 &lt;span&gt;标签用来布局,一行上可以多个&lt;span&gt;小盒子 3.5 图像标签和路径(重点)3.5.1 图像标签 属性 属性值 说明 SrC 图片路径 必须属性 alt 文本 替换文本。图像不能显示的文字 title 文本 提示文本。鼠标放到图像上,显示的文字 width 像素 设置图像的宽度 height 像素 设置图像的高度 border 像素 设置图像的边框粗细 1&lt;img src=\"img.jpg\" alt=\"图像显示不出来的文字\" title=\"鼠标到图片上显示的文字\" width=\"500\" height=\"100\" border=\"15\"/&gt; 图像标签属性注意点: 图像标签可以拥有多个属性,必须写在标签名的后面。 属性之间不分先后顺序,标签名与属性、属性与属性之间均以空格分开。 属性采取键值对的格式,即key= “value” 的格式,属性=“属性值”。 3.5.2 路径相对路径相对路径:以引用文件所在位置为参考基础,而建立出的目录路径。 图片相对于HTML页面的位置 相对路径分类 符号 说明 同一级路径 图像文件位于HTML文件同一级如&lt;img src=&quot;baidu.gif&quot; /&gt; 下一级路径 / 图像文件位于HTML文件下一级 如&lt;img src=&quot;images/baidu.gif /&gt; 上一级路径 ../ 图像文件位于HTML文件上一级如&lt;img src=&quot;../baidu.gif&quot; /&gt; 绝对路径绝对路径:是指目录下的绝对位置,直接到达目标位置,通常是从盘符开始的路径。 3.6 超链接标签(重点)3.6.1 链接的语法格式1&lt;a href=\"跳转目标\" target=\" 目标窗口的弹出方式\"&gt;文本或图像&lt;/a&gt; 属性 作用 href 用于指定链接目标的url地址，(必须属性)当为标签应用href属性时， 它就具有了超链接的功能 target 用于指定链接页面的打开方式，其中_self为默认值，_blank为在新窗口中打开方式。 3.6.2 链接分类: 外部链接: 例如&lt;a href= *http://www.baidu.com*&gt;百度&lt;/a&gt; 内部链接:网站内部页面之间的相互链接直接链接内部页面名称即可,例如&lt;a href= *index.html*&gt;首页&lt;/a&gt; 空链接: 如果当时没有确定链接目标时, &lt;a href=&quot;#&quot;&gt;首页&lt;/&gt; 下载链接: 如果href里面地址是一个文件或者压缩包,会下载这个文件。 网页元素链接:在网页中的各种网页元素,如文本、图像、表格、音频、视频等都可以添加超链接。 锚点链接:点击链接,可以快速定位到页面中的某个位置。 在链接文本的href属性中,设置属性值为#名字的形式,如&lt;a href=&quot; #two&quot;&gt;第2集&lt;/a&gt; 找到目标位置标签,里面添加一个id属性=刚才的名字,如:&lt;h3 id= &quot;two&quot;&gt;第2集介绍&lt;/h3&gt; 4. HTML中的注释和特殊字符4.1 注释&lt;!--注释语句--&gt; 快捷键: ctrl + / 4.2 特殊字符 特殊字符 描述 字符的代码 空格符 &amp;nbsp; ＜ 小于号 &amp;lt; ＞ 大于号 &amp;gt; &amp; 和号 &amp;amp; ￥ 人民币 &amp;yen; © 版权 &amp;copy; ® 注册商标 &amp;reg; ℃ 摄氏度 &amp;deg; ± 正负号 &amp;plusmn; × 乘号 &amp;times; ÷ 除号 &amp;divide; ² 平方2 (上标2) &amp;sup2; ³ 立方3 (上标3) &amp;sup3;","categories":[{"name":"前端","slug":"前端","permalink":"https://duvin0512.github.io./categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://duvin0512.github.io./tags/HTML5/"},{"name":"CSS3","slug":"CSS3","permalink":"https://duvin0512.github.io./tags/CSS3/"}]},{"title":"前端01-HTML简介","slug":"Frontend01","date":"2020-05-29T11:22:35.000Z","updated":"2020-06-03T06:38:34.000Z","comments":true,"path":"2020/05/29/Frontend01/","link":"","permalink":"https://duvin0512.github.io./2020/05/29/Frontend01/","excerpt":"网页的基本组成 常用浏览器 Web标准","text":"网页的基本组成 常用浏览器 Web标准 1.网页1.1 网页的概念网站是指在因特网上根据定的规则,使用HTML等制作的用于展示特定内容相关的网页集合. 网页是网站中的一“页”, 通常是HTML格式的文件,它要通过浏览器来阅读。 网页是构成网站的基本元素,它通常由图片、链接、文字声音、视频等元素组成，通常我们看到的网页,常见以.htm或.html后缀结尾的文件,因此将其俗称为HTML文件。 1.2 什么是HTMLHTML指的是超文本标记语言(Hyper Text Markup Language) ,它是用来描述网页的一种语言， HTML不是一种编程语言,而是一种标记语言(markup language)。 标记语言是一套标记标签(markup tag)。 所谓超文本,有2层含义: 它可以加入图片、声音、动画、多媒体等内容(超越了文本限制)。 它还可以从一个文件跳转到另一个文件,与世界各地主机的文件连接(超级链接文本)。 1.3 网页的形成前端人员开发代码————&gt;浏览器显示代码（解析、渲染）————&gt;生成Web页面 2.常用浏览器2.1 浏览器内核浏览器内核(渲染引擎):负责读取网页内容,整理讯息,计算网页的显示方式并显示页面。 3.Web标准3.1 为什么需要Web标准遵循Web标准除了可以让不同的开发人员写出的页面更标准、更统外,还有以下优点: 让Web的发展前景更广阔。 内容能被更广泛的设备访问。 更容易被搜寻引擎搜索。 降低网站流量费用。 使网站更易于维护。 提高页面浏览速度。 3.2 Web标准的构成主要包括结构(Structure)、表现(Presentation)和行为(Behavior)三个方面。 标准 说明 结构 结构用于对网页元素进行整理和分类，现阶段主要学的是HTML 表现 表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS 行为 行为是指网页模型的定义及交互的编写，现阶段主要学的是Javascript Web标准提出的最佳体验方案:结构、样式、行为相分离。","categories":[{"name":"前端","slug":"前端","permalink":"https://duvin0512.github.io./categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://duvin0512.github.io./tags/HTML5/"},{"name":"CSS3","slug":"CSS3","permalink":"https://duvin0512.github.io./tags/CSS3/"}]}],"categories":[{"name":"blog","slug":"blog","permalink":"https://duvin0512.github.io./categories/blog/"},{"name":"Matlab","slug":"Matlab","permalink":"https://duvin0512.github.io./categories/Matlab/"},{"name":"python","slug":"python","permalink":"https://duvin0512.github.io./categories/python/"},{"name":"数据库","slug":"数据库","permalink":"https://duvin0512.github.io./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"前端","slug":"前端","permalink":"https://duvin0512.github.io./categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://duvin0512.github.io./tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"https://duvin0512.github.io./tags/hexo/"},{"name":"Matlab","slug":"Matlab","permalink":"https://duvin0512.github.io./tags/Matlab/"},{"name":"Matlab初阶+中阶","slug":"Matlab初阶-中阶","permalink":"https://duvin0512.github.io./tags/Matlab%E5%88%9D%E9%98%B6-%E4%B8%AD%E9%98%B6/"},{"name":"python","slug":"python","permalink":"https://duvin0512.github.io./tags/python/"},{"name":"python基础","slug":"python基础","permalink":"https://duvin0512.github.io./tags/python%E5%9F%BA%E7%A1%80/"},{"name":"pyhton基础","slug":"pyhton基础","permalink":"https://duvin0512.github.io./tags/pyhton%E5%9F%BA%E7%A1%80/"},{"name":"网络编程","slug":"网络编程","permalink":"https://duvin0512.github.io./tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"blog配置","slug":"blog配置","permalink":"https://duvin0512.github.io./tags/blog%E9%85%8D%E7%BD%AE/"},{"name":"数据库基础","slug":"数据库基础","permalink":"https://duvin0512.github.io./tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"name":"HTML5","slug":"HTML5","permalink":"https://duvin0512.github.io./tags/HTML5/"},{"name":"CSS3","slug":"CSS3","permalink":"https://duvin0512.github.io./tags/CSS3/"}]}